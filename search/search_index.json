{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"AC Bridge","text":"<p>AI-Generated Project</p> <p>This repo was written primarily using gen-AI (Claude Sonnet 4.5) and serves to enable apex-seeker.</p> <p>Clean plumbing layer for building Gymnasium RL environments with Assetto Corsa.</p> <p>This repo: Windows integration (telemetry + control + timing) Your repo (e.g., apex-seeker): RL logic (rewards + done + PPO)</p>"},{"location":"#features","title":"Features","text":"<ul> <li>ACBridgeLocal - Main API with background telemetry (60 Hz) + vJoy control</li> <li>RealTimeStepper - Drift-correcting step timing for consistent RL training</li> <li>Action Smoothing - Rate limiting + EMA filtering for stable RL training at 10 Hz</li> <li>Comprehensive telemetry - 40+ fields including damage, lap timing, track limits</li> <li>Low latency - 3-8ms control, sub-ms telemetry reads (cached)</li> <li>Actor-learner ready - WebSocket streaming for cloud training</li> <li>Type-safe - Protocol with JSON/MessagePack support</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<p>For apex-seeker (or your Gym env):</p> <pre><code>from ac_bridge import ACBridgeLocal, RealTimeStepper\n\n# Initialize\nbridge = ACBridgeLocal(telemetry_hz=60, control_hz=10)\nstepper = RealTimeStepper(bridge, control_hz=10)\nbridge.connect()\n\n# In your Gym env\nobs, info = stepper.reset()            # Restarts session\nobs, info = stepper.step(action)       # Applies action, waits, returns obs\nreward = compute_reward(obs, info)     # Your logic\ndone = check_done(info)                # Your logic\n\nbridge.close()\n</code></pre> <p>CLI Tools (for testing):</p> <pre><code># Install\nuv sync &amp;&amp; uv pip install -e .\n\n# Test with AC running\nuv run ac-bridge test-telemetry --hz 10\nuv run ac-bridge smoke-test\nuv run ac-bridge test-control\n</code></pre>"},{"location":"#action-smoothing","title":"Action Smoothing","text":"<p>Enabled by default to stabilize RL training:</p> <pre><code>from ac_bridge import ACBridgeLocal, get_aggressive_config, get_no_smoothing_config\n\n# Moderate smoothing (default - recommended for training)\nbridge = ACBridgeLocal(control_hz=10)\n\n# More responsive (for advanced policies)\nbridge = ACBridgeLocal(control_hz=10, smoothing_config=get_aggressive_config())\n\n# Disable smoothing (hard clamps only)\nbridge = ACBridgeLocal(control_hz=10, smoothing_config=get_no_smoothing_config())\n</code></pre> <p>Smoothing includes:</p> <ul> <li>Rate limiting - Limits how fast inputs can change (prevents jerky steering)</li> <li>EMA filtering - Removes noisy outputs without lag</li> <li>Asymmetric pedals - Realistic brake/throttle dynamics (fast brake, slow release)</li> <li>Hard clamps - Always enforces [-1, 1] steering, [0, 1] pedals</li> </ul> <p>This dramatically stabilizes RL training at 10 Hz by preventing spin-outs from sudden control changes.</p>"},{"location":"#what-you-get","title":"What You Get","text":"<p>Observation: 15-dim normalized vector + 40+ field info dict Timing: Drift-correcting 10 Hz steps, &lt;1ms accuracy Control: vJoy with 3-8ms latency + action smoothing Smoothing: Rate limiting + EMA filtering (prevents jerky inputs) Reset: Automated session restart + 1st gear Cloud: WebSocket streaming for distributed training</p>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Windows</li> <li>Python 3.11+</li> <li>Assetto Corsa (original)</li> <li>vJoy virtual joystick driver</li> </ul>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Installation Guide - Set up AC Bridge</li> <li>Quick Start - Build your first integration</li> <li>API Overview - Explore the core API</li> </ul>"},{"location":"#attribution","title":"Attribution","text":"<p>Based on research from:</p> <ul> <li>DIY-DirectDrive - Shared memory structures</li> <li>ac-remote-telemetry-client - UDP protocol reference</li> <li>CrewChiefV4 - UDP protocol analysis</li> <li>assetto_corsa_gym - A fully featured Assetto Corsa Gym Environment</li> </ul> <p>Info</p> <p>UDP telemetry was explored but abandoned in favor of shared memory due to reliability issues and higher latency.</p>"},{"location":"#license","title":"License","text":"<p>MIT License - See LICENSE file for details</p>"},{"location":"action_smoothing/","title":"Action Smoothing","text":"<p>Action smoothing is critical for stable RL training at 10 Hz control rates.</p> <p>Without smoothing, policies produce jerky, unstable inputs that: - Cause spin-outs - Make training diverge - Produce unrealistic behavior</p> <p>With smoothing, you get: - Smooth, human-like inputs - Stable training - Faster convergence</p>"},{"location":"action_smoothing/#the-golden-rule","title":"The Golden Rule","text":"<p>Policy chooses targets, controller decides how fast to reach them.</p> <p>This separation is critical. The RL policy outputs target values, and the smoother gradually moves toward them.</p>"},{"location":"action_smoothing/#components","title":"Components","text":""},{"location":"action_smoothing/#1-rate-limiting-most-important","title":"1. Rate Limiting (Most Important)","text":"<p>Limits how much an input can change per timestep.</p> <p>Example (steering at 10 Hz): <pre><code>max_steer_delta = 0.15  # per step\n# This means: full lock in ~0.7 seconds\n</code></pre></p> <p>Different limits per control: - Steering: Small, smooth (0.10-0.15) - Throttle: Moderate (0.10 up, 0.25 down) - Brake: Fast application, slow release (0.30 up, 0.10 down)</p>"},{"location":"action_smoothing/#2-low-pass-filtering-ema-smoothing","title":"2. Low-Pass Filtering (EMA Smoothing)","text":"<p>Removes noisy outputs without lagging.</p> <pre><code>alpha = 0.6  # 0=full smoothing, 1=no smoothing\nsteer = alpha * target + (1 - alpha) * prev_steer\n</code></pre> <p>Typical values at 10 Hz: - Steering: 0.5-0.7 - Throttle: 0.6-0.8 - Brake: 0.6-0.8</p>"},{"location":"action_smoothing/#3-asymmetric-pedal-dynamics","title":"3. Asymmetric Pedal Dynamics","text":"<p>Models realistic human behavior: - Apply brake quickly, release slowly - Apply throttle smoothly, lift faster</p> <p>This alone stops 80% of spin-outs.</p>"},{"location":"action_smoothing/#4-hard-clamps-always-applied","title":"4. Hard Clamps (Always Applied)","text":"<p>Safety layer that always enforces: - Steering: [-1.0, 1.0] - Pedals: [0.0, 1.0]</p> <p>Never trust raw NN outputs.</p>"},{"location":"action_smoothing/#usage","title":"Usage","text":""},{"location":"action_smoothing/#default-recommended","title":"Default (Recommended)","text":"<pre><code>from ac_bridge import ACBridgeLocal\n\n# Moderate smoothing enabled by default\nbridge = ACBridgeLocal(telemetry_hz=60, control_hz=10)\nbridge.connect()\n\n# Smoothing happens automatically in apply_action()\nbridge.apply_action(steer=0.5, throttle=0.8, brake=0.0)\n</code></pre>"},{"location":"action_smoothing/#custom-config","title":"Custom Config","text":"<pre><code>from ac_bridge import ACBridgeLocal, SmoothingConfig\n\nconfig = SmoothingConfig(\n    enable_rate_limiting=True,\n    max_steer_delta=0.10,      # More conservative\n    enable_ema_smoothing=True,\n    steer_alpha=0.5            # More smoothing\n)\n\nbridge = ACBridgeLocal(\n    telemetry_hz=60,\n    control_hz=10,\n    smoothing_config=config\n)\n</code></pre>"},{"location":"action_smoothing/#presets","title":"Presets","text":"<pre><code>from ac_bridge import (\n    ACBridgeLocal,\n    get_conservative_config,  # Very smooth, human-like\n    get_moderate_config,      # Balanced (default)\n    get_aggressive_config,    # More responsive\n    get_no_smoothing_config   # Hard clamps only\n)\n\n# Conservative (good for initial training)\nbridge = ACBridgeLocal(\n    control_hz=10,\n    smoothing_config=get_conservative_config()\n)\n\n# No smoothing (not recommended for RL)\nbridge = ACBridgeLocal(\n    control_hz=10,\n    smoothing_config=get_no_smoothing_config()\n)\n</code></pre>"},{"location":"action_smoothing/#monitoring","title":"Monitoring","text":"<pre><code># Get smoothing statistics\nstats = bridge.get_smoother_stats()\n\nprint(f\"Steps: {stats['step_count']}\")\nprint(f\"Avg steer delta: {stats['avg_steer_delta']:.4f}\")\nprint(f\"Avg throttle delta: {stats['avg_throttle_delta']:.4f}\")\nprint(f\"Config: {stats['config']}\")\n</code></pre>"},{"location":"action_smoothing/#when-to-use-each-preset","title":"When to Use Each Preset","text":""},{"location":"action_smoothing/#conservative","title":"Conservative","text":"<ul> <li>When: Initial training, learning from scratch</li> <li>Why: Prevents catastrophic failures early on</li> <li>Trade-off: Slower reactions, less responsive</li> </ul>"},{"location":"action_smoothing/#moderate-default","title":"Moderate (Default)","text":"<ul> <li>When: General training, most use cases</li> <li>Why: Good balance of stability and responsiveness</li> <li>Trade-off: Minimal, recommended default</li> </ul>"},{"location":"action_smoothing/#aggressive","title":"Aggressive","text":"<ul> <li>When: Fine-tuning advanced policies, racing</li> <li>Why: More responsive, closer to expert behavior</li> <li>Trade-off: Requires stable policy to avoid spin-outs</li> </ul>"},{"location":"action_smoothing/#no-smoothing","title":"No Smoothing","text":"<ul> <li>When: Debugging, analyzing raw policy outputs</li> <li>Why: See what the policy actually wants to do</li> <li>Trade-off: Unstable, jerky, not suitable for training</li> </ul>"},{"location":"action_smoothing/#testing","title":"Testing","text":"<p>Run the smoothing test to see the difference:</p> <pre><code># Start AC and enter a session, then:\nuv run examples/test_action_smoothing.py\n</code></pre> <p>This will: 1. Test moderate smoothing (default) 2. Test aggressive smoothing 3. Test no smoothing (you'll see the difference!)</p>"},{"location":"action_smoothing/#implementation-details","title":"Implementation Details","text":"<p>The <code>ActionSmoother</code> class is integrated into <code>ACBridgeLocal.apply_action()</code>:</p> <ol> <li>Phase 0: Hard clamp inputs (always)</li> <li>Phase 1: Apply rate limiting (if enabled)</li> <li>Phase 2: Apply EMA smoothing (if enabled)</li> <li>Phase 3: Final safety clamps (always)</li> </ol> <p>State is automatically reset when <code>bridge.reset()</code> is called.</p>"},{"location":"action_smoothing/#performance","title":"Performance","text":"<p>Smoothing adds negligible overhead: - Rate limiting: Simple clipping, ~0.01ms - EMA filtering: Single multiply-add, ~0.01ms - Total: &lt;0.05ms per action</p> <p>This is insignificant compared to vJoy update latency (3-8ms).</p>"},{"location":"action_smoothing/#references","title":"References","text":"<ul> <li>Soft Actor-Critic - Action smoothing improves sample efficiency</li> <li>DDPG - Exploration noise vs. output smoothing</li> <li>TD3 - Target policy smoothing</li> </ul>"},{"location":"action_smoothing/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>Always use smoothing for RL training</li> <li>Start with moderate config</li> <li>Monitor avg_steer_delta - should be &lt;0.15 at 10 Hz</li> <li>Don't trust raw NN outputs - always clamp and smooth</li> <li>Smoothing \u2260 lag - EMA with alpha=0.6 is responsive</li> </ol> <p>Without smoothing, RL training in racing simulators is nearly impossible at low control rates (10 Hz).</p>"},{"location":"api_reference/","title":"AC Bridge API Reference","text":"<p>Comprehensive but concise reference for the ac-bridge Python API.</p>"},{"location":"api_reference/#core-classes","title":"Core Classes","text":""},{"location":"api_reference/#acbridgelocal","title":"ACBridgeLocal","text":"<p>Main bridge for same-machine RL training. Polls AC telemetry in background thread, exposes latest frame via thread-safe cache.</p> <pre><code>from ac_bridge import ACBridgeLocal\n\nbridge = ACBridgeLocal(\n    telemetry_hz=60,   # Background polling rate\n    control_hz=10,     # Target step rate (for stepper)\n    controller=\"vjoy\", # Controller type\n    device_id=1,       # vJoy device ID\n    obs_dim=15         # Observation vector dimension\n)\n</code></pre> <p>Methods:</p> <ul> <li><code>connect()</code> - Start telemetry thread, wait for first frame</li> <li><code>close()</code> - Stop threads, cleanup resources</li> <li><code>is_connected()</code> - Check if telemetry available</li> <li><code>latest_obs() -&gt; (obs, info)</code> - Get cached latest frame (instant, non-blocking)</li> <li><code>apply_action(steer, throttle, brake, clutch=0.0)</code> - Send control to vJoy</li> <li><code>reset(wait_time=5.0)</code> - Restart session (buttons 7+9), reset controls, shift to 1st</li> </ul> <p>Observation Format:</p> <p>15-dim normalized float32 array: <pre><code>[0] speed (0-300 km/h \u2192 0-1)\n[1-3] velocity x/y/z\n[4-6] throttle/brake/steerAngle\n[7-8] rpm/gear\n[9-11] g-forces (lateral/longitudinal/vertical)\n[12] avg wheel slip\n[13] tyres out (0-4 \u2192 0-1)\n[14] damage indicator (binary)\n</code></pre></p> <p>Info Dict Fields:</p> <p>Timing: <code>seq</code>, <code>t_wall</code>, <code>dt</code>, <code>dt_actual</code> Driving: <code>speed_kmh</code>, <code>rpm</code>, <code>gear</code>, <code>throttle</code>, <code>brake</code>, <code>steer_angle</code> Position: <code>position</code>, <code>velocity</code>, <code>local_velocity</code>, <code>angular_velocity</code> Track: <code>tyres_out</code>, <code>is_valid_lap</code>, <code>completed_laps</code>, <code>current_time</code>, <code>distance_traveled</code> Damage: <code>car_damage</code>, <code>bodywork_damaged</code>, <code>bodywork_critical</code>, <code>tyre_wear</code>, <code>tyre_damaged</code> Environment: <code>surface_grip</code>, <code>air_temp</code>, <code>road_temp</code>, <code>is_in_pit_lane</code></p>"},{"location":"api_reference/#realtimestepper","title":"RealTimeStepper","text":"<p>Enforces consistent step timing for RL. Wraps ACBridgeLocal with drift-correcting ticker.</p> <pre><code>from ac_bridge import ACBridgeLocal, RealTimeStepper\n\nbridge = ACBridgeLocal(telemetry_hz=60, control_hz=10)\nstepper = RealTimeStepper(bridge, control_hz=10)\nbridge.connect()\n</code></pre> <p>Methods:</p> <ul> <li><code>step(action) -&gt; (obs, info)</code> - Apply action, wait for tick, return observation</li> <li><code>reset() -&gt; (obs, info)</code> - Trigger session reset, return initial observation</li> <li><code>get_stats()</code> - Get timing statistics</li> </ul> <p>Action Format:</p> <p>numpy array: <code>[steer, throttle, brake]</code> or <code>[steer, throttle, brake, clutch]</code> - steer: -1.0 (left) to 1.0 (right) - throttle/brake/clutch: 0.0 to 1.0</p>"},{"location":"api_reference/#ticker","title":"Ticker","text":"<p>Drift-correcting frequency generator. Maintains precise timing over long runs.</p> <pre><code>from ac_bridge import Ticker\n\nticker = Ticker(hz=10)  # 10 Hz = 0.1s steps\nfor seq, t_wall, dt, dt_actual in ticker:\n    # Execute at precise 10 Hz\n    process_step()\n</code></pre> <p>Methods:</p> <ul> <li><code>tick() -&gt; (seq, t_wall, dt, dt_actual)</code> - Yield next tick</li> <li><code>reset(start_seq=0)</code> - Reset ticker for new episode</li> <li><code>get_stats()</code> - Get drift and jitter statistics</li> </ul>"},{"location":"api_reference/#protocol-types","title":"Protocol Types","text":""},{"location":"api_reference/#telemetryframe","title":"TelemetryFrame","text":"<pre><code>from ac_bridge.protocol import TelemetryFrame\n\nframe = TelemetryFrame(\n    seq=42,\n    t_wall=123.456,\n    dt=0.1,\n    dt_actual=0.0987,\n    obs=np.array([...]),\n    info={...}\n)\n</code></pre>"},{"location":"api_reference/#controlcommand","title":"ControlCommand","text":"<pre><code>from ac_bridge.protocol import ControlCommand\n\ncmd = ControlCommand(\n    seq=42,\n    steer=0.2,\n    throttle=0.8,\n    brake=0.0,\n    clutch=0.0\n)\n</code></pre>"},{"location":"api_reference/#codec","title":"Codec","text":"<p>Encode/decode messages (JSON or MessagePack):</p> <pre><code>from ac_bridge.protocol import Message, Codec\n\nmsg = Message(type=MessageType.TELEMETRY, payload={...})\nbytes_data = Codec.encode(msg, format='json')  # or 'msgpack'\ndecoded = Codec.decode(bytes_data, format='json')\n</code></pre>"},{"location":"api_reference/#usage-patterns","title":"Usage Patterns","text":""},{"location":"api_reference/#pattern-1-basic-training-loop","title":"Pattern 1: Basic Training Loop","text":"<pre><code>from ac_bridge import ACBridgeLocal\n\nbridge = ACBridgeLocal(telemetry_hz=60, control_hz=10)\nbridge.connect()\n\nfor episode in range(1000):\n    bridge.reset()  # Restart session\n\n    for step in range(100):\n        obs, info = bridge.latest_obs()\n        action = policy(obs)  # Your RL policy\n        bridge.apply_action(*action)\n        time.sleep(0.1)  # 10 Hz\n\nbridge.close()\n</code></pre>"},{"location":"api_reference/#pattern-2-gym-environment-recommended","title":"Pattern 2: Gym Environment (Recommended)","text":"<pre><code>from ac_bridge import ACBridgeLocal, RealTimeStepper\nimport gymnasium as gym\n\nclass AssettoCorsa_v0(gym.Env):\n    def __init__(self):\n        self.bridge = ACBridgeLocal(telemetry_hz=60, control_hz=10)\n        self.stepper = RealTimeStepper(self.bridge, control_hz=10)\n        self.bridge.connect()\n\n        self.observation_space = gym.spaces.Box(-1, 1, (15,), np.float32)\n        self.action_space = gym.spaces.Box(\n            np.array([-1, 0, 0]), np.array([1, 1, 1]), np.float32\n        )\n\n    def reset(self, seed=None, options=None):\n        super().reset(seed=seed)\n        obs, info = self.stepper.reset()\n        return obs, info\n\n    def step(self, action):\n        obs, info = self.stepper.step(action)  # Handles timing\n        reward = self._compute_reward(obs, info)\n        done = self._is_done(info)\n        return obs, reward, done, False, info\n\n    def _compute_reward(self, obs, info):\n        reward = info['speed_kmh'] / 100.0\n        if info['tyres_out'] &gt; 2:\n            reward -= 10.0\n        return reward\n\n    def _is_done(self, info):\n        return info['tyres_out'] &gt;= 4 or info['bodywork_critical']\n\n    def close(self):\n        self.bridge.close()\n</code></pre>"},{"location":"api_reference/#pattern-3-cloud-training-actor-learner","title":"Pattern 3: Cloud Training (Actor-Learner)","text":"<pre><code># Windows (actor)\nfrom ac_bridge import ACBridgeLocal\n\nbridge = ACBridgeLocal(telemetry_hz=60, control_hz=10)\nbridge.connect()\n\nwhile training:\n    obs, info = bridge.latest_obs()\n    action = local_policy(obs)  # Inference locally\n    bridge.apply_action(*action)\n\n    # Batch transitions and send to cloud\n    transitions.append((obs, action, reward, next_obs, done))\n    if len(transitions) &gt;= 100:\n        send_to_cloud(transitions)\n        transitions.clear()\n</code></pre>"},{"location":"api_reference/#performance","title":"Performance","text":"<ul> <li>Telemetry polling: 60 Hz background thread</li> <li>Control latency: 3-8ms (vJoy)</li> <li>Step timing accuracy: &lt;1ms drift over 1000 steps</li> <li>Observation overhead: ~0.1ms (cached)</li> </ul>"},{"location":"api_reference/#error-handling","title":"Error Handling","text":"<pre><code>bridge = ACBridgeLocal()\nbridge.connect()\n\ntry:\n    obs, info = bridge.latest_obs()\nexcept RuntimeError:\n    # AC not connected or no telemetry available\n    pass\n\n# Always cleanup\nbridge.close()\n</code></pre>"},{"location":"api_reference/#cli-commands","title":"CLI Commands","text":"<p>Quick reference for terminal usage:</p> <pre><code># Main bridge loop (monitoring)\nuv run ac-bridge run --hz 10\n\n# Test telemetry reading\nuv run ac-bridge test-telemetry --hz 10 --duration 30\n\n# Test control output\nuv run ac-bridge test-control\n\n# Full integration test\nuv run ac-bridge smoke-test --duration 10\n\n# Reset session\nuv run ac-bridge reset\n\n# Stream to cloud\nuv run ac-bridge cloud --uri ws://your-server:8765\n</code></pre>"},{"location":"api_reference/#thread-safety","title":"Thread Safety","text":"<p><code>ACBridgeLocal</code> is thread-safe: - Background thread polls telemetry - Main thread calls <code>latest_obs()</code> (reads from cache with lock) - Control calls are synchronous (vJoy is not thread-safe)</p> <p>Safe: Multiple <code>latest_obs()</code> calls from different threads Unsafe: Multiple <code>apply_action()</code> calls (use single control thread)</p>"},{"location":"api_reference/#timing-guarantees","title":"Timing Guarantees","text":"<ul> <li>Ticker: Maintains target frequency with drift correction</li> <li>dt_actual: Actual time since last frame (use for physics-based rewards)</li> <li>seq: Monotonic sequence number (detect dropped frames)</li> </ul> <p>If <code>seq</code> jumps (e.g., 42\u219244), one frame was dropped. This is rare but possible under heavy load.</p>"},{"location":"api_reference/#customization","title":"Customization","text":""},{"location":"api_reference/#custom-observation-space","title":"Custom Observation Space","text":"<p>Edit <code>ACBridgeLocal._read_and_process_telemetry()</code> to change observation vector:</p> <pre><code>obs = np.array([\n    # Your custom features\n    info['speed_kmh'] / 300.0,\n    info['distance_traveled'] / 10000.0,\n    # ... add more fields\n], dtype=np.float32)\n</code></pre>"},{"location":"api_reference/#custom-reset-behavior","title":"Custom Reset Behavior","text":"<p>Modify <code>ACBridgeLocal.reset()</code> to change button sequence or wait times.</p>"},{"location":"api_reference/#attribution","title":"Attribution","text":"<p>Based on: - DIY-DirectDrive - Shared memory structures - assetto_corsa_gym - vJoy control patterns</p>"},{"location":"api_reference/#version","title":"Version","text":"<p>ac-bridge v0.2.0</p>"},{"location":"cloud_setup/","title":"Cloud Setup Guide","text":""},{"location":"cloud_setup/#problem-nat-and-firewall","title":"Problem: NAT and Firewall","text":"<p>Your home Windows PC running AC is behind NAT/firewall, so cloud instances (EC2, etc.) cannot directly connect to it. The solution is to reverse the connection direction.</p>"},{"location":"cloud_setup/#solution-windows-dials-out-to-cloud","title":"Solution: Windows Dials OUT to Cloud","text":"<p>Have your Windows machine connect TO your cloud server. This works because: - Outbound connections are allowed through NAT - No port forwarding required on home router - No public IP needed on Windows machine - Works from anywhere (home, cafe, etc.)</p>"},{"location":"cloud_setup/#architecture","title":"Architecture","text":"<pre><code>Windows PC (AC + Bridge)  --&gt;  Cloud Server (EC2)  --&gt;  Training\n   Behind NAT                   Public IP               GPUs\n\nConnection flow:\n1. Cloud server starts WebSocket server on port 8765\n2. Windows bridge connects TO cloud server\n3. Bridge streams telemetry through persistent connection\n4. Training code receives telemetry in real-time\n</code></pre>"},{"location":"cloud_setup/#setup-steps","title":"Setup Steps","text":""},{"location":"cloud_setup/#1-cloud-server-setup-ec2","title":"1. Cloud Server Setup (EC2)","text":"<p>Launch EC2 Instance: <pre><code># Ubuntu 22.04 LTS recommended\n# Instance type: t3.medium or better\n# Storage: 20GB minimum\n</code></pre></p> <p>Configure Security Group: <pre><code>Inbound Rules:\n- Port 8765 (WebSocket): TCP from YOUR_HOME_IP/32\n- Port 22 (SSH): TCP from YOUR_HOME_IP/32\n</code></pre></p> <p>Install Dependencies: <pre><code># SSH into EC2\nssh -i your-key.pem ubuntu@your-ec2-ip\n\n# Install Python 3.11+\nsudo apt update\nsudo apt install python3.11 python3.11-venv python3-pip -y\n\n# Install websockets\npip3 install websockets\n</code></pre></p> <p>Start Receiver Server: <pre><code># Copy cloud_server.py to EC2\nscp -i your-key.pem examples/cloud_server.py ubuntu@your-ec2-ip:~/\n\n# Run server\npython3 cloud_server.py --host 0.0.0.0 --port 8765\n</code></pre></p>"},{"location":"cloud_setup/#2-windows-bridge-setup","title":"2. Windows Bridge Setup","text":"<p>Start Streaming to Cloud: <pre><code># On your Windows PC\nuv run main.py cloud --uri ws://YOUR_EC2_IP:8765 --rate 10\n</code></pre></p> <p>That's it! The bridge will: - Connect to your EC2 instance - Stream telemetry at 10 Hz - Auto-reconnect if connection drops - Continue streaming as long as AC is running</p>"},{"location":"cloud_setup/#3-test-connection","title":"3. Test Connection","text":"<p>On EC2 (watch for incoming data): <pre><code>python3 cloud_server.py --host 0.0.0.0 --port 8765\n\n# Should show:\n# [YOUR_IP:PORT] Client connected\n# [#10] Speed: 145.3 km/h | Lap: 2 | Valid: True\n# [#20] Speed: 152.1 km/h | Lap: 2 | Valid: True\n</code></pre></p> <p>On Windows (should show connection success): <pre><code>uv run main.py cloud --uri ws://YOUR_EC2_IP:8765 --rate 10\n\n# Should show:\n# connected_to_server uri=ws://YOUR_EC2_IP:8765\n# telemetry_stream_started rate_hz=10\n</code></pre></p>"},{"location":"cloud_setup/#secure-connection-recommended-for-production","title":"Secure Connection (Recommended for Production)","text":"<p>For production use, enable TLS:</p>"},{"location":"cloud_setup/#1-get-ssl-certificate","title":"1. Get SSL Certificate","text":"<pre><code># Install certbot on EC2\nsudo apt install certbot\n\n# Get certificate (requires domain name)\nsudo certbot certonly --standalone -d your-domain.com\n</code></pre>"},{"location":"cloud_setup/#2-run-server-with-tls","title":"2. Run Server with TLS","text":"<p>Modify <code>cloud_server.py</code> to use SSL:</p> <pre><code>import ssl\n\nssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\nssl_context.load_cert_chain('/etc/letsencrypt/live/your-domain.com/fullchain.pem',\n                            '/etc/letsencrypt/live/your-domain.com/privkey.pem')\n\nasync with websockets.serve(self.handler, self.host, self.port, ssl=ssl_context):\n    await asyncio.Future()\n</code></pre>"},{"location":"cloud_setup/#3-connect-with-wss","title":"3. Connect with WSS","text":"<pre><code>uv run main.py cloud --uri wss://your-domain.com:8765 --rate 10\n</code></pre>"},{"location":"cloud_setup/#firewall-configuration","title":"Firewall Configuration","text":""},{"location":"cloud_setup/#ec2-security-group","title":"EC2 Security Group","text":"<pre><code>Inbound:\n- Type: Custom TCP\n- Port: 8765\n- Source: YOUR_HOME_IP/32  # Restrict to your IP for security\n\nOutbound:\n- All traffic allowed (default)\n</code></pre>"},{"location":"cloud_setup/#windows-firewall","title":"Windows Firewall","text":"<p>No configuration needed - outbound connections are allowed by default.</p>"},{"location":"cloud_setup/#troubleshooting","title":"Troubleshooting","text":""},{"location":"cloud_setup/#connection-refused","title":"Connection Refused","text":"<pre><code>Error: connection_error error=[Errno 111] Connection refused\n</code></pre> <p>Fix: - Verify EC2 security group allows port 8765 from your IP - Verify cloud server is running - Check EC2 IP address is correct</p>"},{"location":"cloud_setup/#connection-timeout","title":"Connection Timeout","text":"<pre><code>Error: connection_error error=asyncio.exceptions.TimeoutError\n</code></pre> <p>Fix: - Verify EC2 instance is running - Check your home network allows outbound connections on port 8765 - Try using a different port (e.g., 443 or 80)</p>"},{"location":"cloud_setup/#auto-reconnect-not-working","title":"Auto-Reconnect Not Working","text":"<p>The bridge automatically reconnects every 5 seconds by default. Adjust:</p> <pre><code>uv run main.py cloud --uri ws://ec2-ip:8765 --reconnect-delay 10\n</code></pre>"},{"location":"cloud_setup/#high-latency","title":"High Latency","text":"<pre><code>Packet delays &gt; 100ms\n</code></pre> <p>Fix: - Choose EC2 region closer to your location - Reduce send rate: <code>--rate 5</code> instead of <code>--rate 10</code> - Check your home internet connection - Use wired connection instead of WiFi</p>"},{"location":"cloud_setup/#cost-optimization","title":"Cost Optimization","text":""},{"location":"cloud_setup/#ec2-instance-sizing","title":"EC2 Instance Sizing","text":"<ul> <li>Development: t3.micro ($0.01/hour)</li> <li>Training: p3.2xlarge ($3.06/hour with GPU)</li> <li>Use Spot Instances: Save 70% on training costs</li> </ul>"},{"location":"cloud_setup/#data-transfer-costs","title":"Data Transfer Costs","text":"<ul> <li>Telemetry: ~500 bytes/packet</li> <li>At 10 Hz: ~5 KB/s = 18 MB/hour = 432 MB/day</li> <li>EC2 data transfer out: First 100 GB/month free</li> <li>Cost: Minimal for telemetry alone</li> </ul>"},{"location":"cloud_setup/#alternative-use-existing-server","title":"Alternative: Use Existing Server","text":"<p>If you have a VPS or other cloud server:</p> <pre><code># Any Linux server with public IP\n# Install websockets: pip install websockets\n# Run cloud_server.py\npython3 cloud_server.py --host 0.0.0.0 --port 8765\n\n# Connect from Windows\nuv run main.py cloud --uri ws://your-vps-ip:8765\n</code></pre>"},{"location":"cloud_setup/#integration-with-training-code","title":"Integration with Training Code","text":"<p>The cloud server receives telemetry as JSON. Integrate with your RL training:</p> <pre><code>import asyncio\nimport json\nimport websockets\nfrom collections import deque\n\nclass TrainingReceiver:\n    def __init__(self):\n        self.buffer = deque(maxlen=1000)\n\n    async def handler(self, websocket):\n        async for message in websocket:\n            telemetry = json.loads(message)\n\n            # Add to buffer\n            self.buffer.append(telemetry)\n\n            # Process for training\n            if len(self.buffer) &gt;= 10:\n                obs = self.extract_observation(telemetry)\n                reward = self.calculate_reward(telemetry)\n                done = self.check_termination(telemetry)\n\n                # Feed to policy...\n\n    def extract_observation(self, t):\n        return [\n            t['speed_kmh'] / 300.0,  # Normalize\n            t['rpm'] / 8000.0,\n            t['yaw'],\n            t['angular_velocity_y'],\n            # ... more features\n        ]\n\n    def calculate_reward(self, t):\n        reward = 0.0\n        reward += t['speed_kmh'] * 0.01  # Progress reward\n        reward -= t['number_of_tyres_out'] * 10  # Off-track penalty\n        reward -= int(t['wheel_lock_detected']) * 5  # Lock penalty\n        return reward\n</code></pre>"},{"location":"cloud_setup/#next-steps","title":"Next Steps","text":"<ol> <li>Set up EC2 instance and start cloud_server.py</li> <li>Test connection from Windows with <code>main.py cloud</code></li> <li>Verify data is flowing (check cloud_server.py output)</li> <li>Integrate with your training pipeline</li> <li>Consider adding authentication for production use</li> </ol>"},{"location":"control/","title":"Control System Documentation","text":""},{"location":"control/#overview","title":"Overview","text":"<p>The control system enables sending commands to Assetto Corsa via vJoy (virtual joystick). This provides low-latency control for reinforcement learning training and automated driving.</p>"},{"location":"control/#architecture","title":"Architecture","text":"<pre><code>graph LR\n    Python[Python Policy] --&gt;|pyvjoy API| vJoyDriver[vJoy Driver]\n    vJoyDriver --&gt;|DirectInput| AC[Assetto Corsa]\n\n    note1[Latency: 3-8ms total]\n</code></pre> <p>Components: - VJoyController: Python class for sending control commands - vJoy Driver: Kernel-mode virtual joystick driver (Windows) - DirectInput: Standard Windows game input API</p> <p>Latency: - Python \u2192 vJoy: 1-2ms - vJoy \u2192 AC: 2-5ms - Total: 3-8ms (comparable to physical wheel)</p>"},{"location":"control/#installation","title":"Installation","text":""},{"location":"control/#1-install-vjoy-driver","title":"1. Install vJoy Driver","text":"<p>Download and install vJoy from: https://sourceforge.net/projects/vjoystick/</p> <p>Run the installer with default settings.</p>"},{"location":"control/#2-configure-vjoy-device","title":"2. Configure vJoy Device","text":"<p>Open \"Configure vJoy\" application:</p> <p>Device 1 Settings: - Enable: \u2713 - Axes:   - X Axis: \u2713 (Steering)   - Y Axis: \u2713 (Throttle)   - Z Axis: \u2713 (Brake)   - RZ Rotation: \u2713 (Clutch) - Buttons: 8 or more - POV Hat Switch: 0 (disabled)</p> <p>Click \"Apply\" to save configuration.</p>"},{"location":"control/#3-install-python-dependencies","title":"3. Install Python Dependencies","text":"<p>The <code>pyvjoy</code> library is included in project dependencies:</p> <pre><code>uv sync\n</code></pre>"},{"location":"control/#4-configure-assetto-corsa","title":"4. Configure Assetto Corsa","text":"<p>In AC, go to Options \u2192 Controls:</p> <ol> <li>Select \"vJoy Device\" as controller</li> <li>Map controls:</li> <li>Throttle: Y Axis</li> <li>Brake: Z Axis</li> <li>Clutch: RZ Axis</li> <li>Steer Left/Right: X Axis</li> <li>Set all axis ranges:</li> <li>Minimum: -100%</li> <li>Maximum: +100%</li> <li>Deadzone: 0%</li> <li>Gamma: 1.0</li> <li>Optional: Map gear up/down to buttons 1 and 2</li> </ol>"},{"location":"control/#usage","title":"Usage","text":""},{"location":"control/#quick-test","title":"Quick Test","text":"<p>Verify vJoy installation:</p> <pre><code>uv run main.py test-control\n</code></pre> <p>Use keyboard controls (W/A/S/D) to test throttle, brake, and steering.</p>"},{"location":"control/#python-api","title":"Python API","text":"<pre><code>from ac_bridge.control import VJoyController\n\n# Initialize controller\ncontroller = VJoyController(device_id=1)\n\n# Set individual controls\ncontroller.set_throttle(0.8)    # 80% throttle\ncontroller.set_brake(0.0)       # No brake\ncontroller.set_steering(-0.5)   # Half left\ncontroller.set_clutch(0.0)      # Clutch released\n\n# Batch update (most efficient)\ncontroller.set_controls(\n    throttle=0.8,\n    brake=0.0,\n    steering=-0.5,\n    clutch=0.0\n)\n\n# Gear shifting\ncontroller.set_gear(3)  # 2nd gear (0=R, 1=N, 2=1st, 3=2nd, ...)\n\n# Reset to neutral\ncontroller.reset()\n\n# Clean up\ncontroller.close()\n</code></pre>"},{"location":"control/#value-ranges","title":"Value Ranges","text":"Control Range Notes Throttle 0.0 - 1.0 0=off, 1=full Brake 0.0 - 1.0 0=off, 1=full Clutch 0.0 - 1.0 0=released, 1=pressed Steering -1.0 - 1.0 -1=full left, 0=center, 1=full right Gear 0-7 0=R, 1=N, 2=1st, 3=2nd, etc."},{"location":"control/#closed-loop-example","title":"Closed-Loop Example","text":"<pre><code>from ac_bridge.telemetry.ac_native_memory import ACSharedMemory\nfrom ac_bridge.control import VJoyController\nimport time\n\nasm = ACSharedMemory()\ncontroller = VJoyController()\n\nwhile True:\n    # Read telemetry\n    p = asm.physics\n    speed = p.speedKmh\n\n    # Simple speed control\n    target_speed = 100.0\n    error = target_speed - speed\n    throttle = max(0.0, min(1.0, error * 0.01))\n\n    # Apply control\n    controller.set_throttle(throttle)\n\n    time.sleep(0.02)  # 50 Hz\n</code></pre>"},{"location":"control/#cloud-training-integration","title":"Cloud Training Integration","text":"<p>On Windows (home PC): <pre><code># Receive controls from cloud\nuv run main.py control-from-cloud --uri ws://your-ec2:8766\n</code></pre></p> <p>On Cloud (EC2): <pre><code>import asyncio\nimport json\nimport websockets\n\nasync def send_controls():\n    async with websockets.connect(\"ws://windows-pc:8766\") as ws:\n        # Send control command\n        controls = {\n            \"throttle\": 0.8,\n            \"brake\": 0.0,\n            \"steering\": -0.2,\n            \"clutch\": 0.0\n        }\n        await ws.send(json.dumps(controls))\n\nasyncio.run(send_controls())\n</code></pre></p>"},{"location":"control/#performance-optimization","title":"Performance Optimization","text":""},{"location":"control/#value-caching","title":"Value Caching","text":"<p>The <code>VJoyController</code> caches values and only sends updates when values change:</p> <pre><code># Only sends one vJoy command (value unchanged)\ncontroller.set_throttle(0.5)\ncontroller.set_throttle(0.5)  # Skipped (cached)\ncontroller.set_throttle(0.6)  # Sent (changed)\n</code></pre>"},{"location":"control/#batch-updates","title":"Batch Updates","text":"<p>Use <code>set_controls()</code> for multiple axes to minimize API calls:</p> <pre><code># Efficient: Single update\ncontroller.set_controls(throttle=0.8, brake=0.0, steering=-0.3)\n\n# Less efficient: Multiple updates\ncontroller.set_throttle(0.8)\ncontroller.set_brake(0.0)\ncontroller.set_steering(-0.3)\n</code></pre>"},{"location":"control/#update-rate","title":"Update Rate","text":"<p>Target 50-100 Hz for smooth control:</p> <pre><code>rate_hz = 60\nsleep_time = 1.0 / rate_hz\n\nwhile running:\n    controller.set_controls(...)\n    time.sleep(sleep_time)\n</code></pre> <p>Higher rates (&gt;100 Hz) provide diminishing returns due to AC's internal polling rate.</p>"},{"location":"control/#troubleshooting","title":"Troubleshooting","text":""},{"location":"control/#error-failed-to-initialize-vjoy-device","title":"Error: Failed to initialize vJoy device","text":"<p>Cause: vJoy driver not installed or device not configured</p> <p>Solution: 1. Install vJoy from https://sourceforge.net/projects/vjoystick/ 2. Open \"Configure vJoy\" and enable device 1 3. Verify 4 axes are enabled (X, Y, Z, RZ) 4. Click \"Apply\"</p>"},{"location":"control/#controls-not-responding-in-ac","title":"Controls not responding in AC","text":"<p>Cause: AC not configured for vJoy</p> <p>Solution: 1. In AC: Options \u2192 Controls \u2192 Controller 2. Select \"vJoy Device\" 3. Map throttle, brake, steering, clutch 4. Remove deadzones (set to 0%) 5. Test controls in AC before using Python</p>"},{"location":"control/#high-latency-jerky-control","title":"High latency / jerky control","text":"<p>Cause: Update rate too low or system overload</p> <p>Solution: 1. Increase control update rate (60-100 Hz) 2. Use <code>set_controls()</code> instead of individual axis updates 3. Reduce telemetry polling rate if CPU-bound 4. Close background applications</p>"},{"location":"control/#vjoy-device-busy-in-use","title":"vJoy device busy / in use","text":"<p>Cause: Another application using vJoy device 1</p> <p>Solution: 1. Close other apps using vJoy 2. Or use different device ID: <code>VJoyController(device_id=2)</code> 3. Configure device 2 in \"Configure vJoy\" first</p>"},{"location":"control/#steeringthrottle-stuck-at-max","title":"Steering/throttle stuck at max","text":"<p>Cause: Axis range misconfigured in AC</p> <p>Solution: 1. AC Options \u2192 Controls \u2192 Axes 2. Set minimum to -100%, maximum to +100% 3. Verify in calibration screen 4. Reset controller: <code>controller.reset()</code></p>"},{"location":"control/#advanced-usage","title":"Advanced Usage","text":""},{"location":"control/#custom-gear-mapping","title":"Custom Gear Mapping","text":"<p>Override gear shifting behavior:</p> <pre><code>class CustomGearController(VJoyController):\n    def set_gear(self, gear: int):\n        # Custom H-pattern mapping using buttons 1-7\n        for i in range(1, 8):\n            self.device.set_button(i, 1 if i == gear else 0)\n</code></pre>"},{"location":"control/#multi-device-setup","title":"Multi-Device Setup","text":"<p>Control multiple vJoy devices:</p> <pre><code># Primary controls\ncontroller1 = VJoyController(device_id=1)\ncontroller1.set_controls(throttle=0.8, brake=0.0, steering=0.0)\n\n# Secondary inputs (e.g., handbrake, DRS)\ncontroller2 = VJoyController(device_id=2)\ncontroller2.device.set_button(1, 1)  # Handbrake\n</code></pre>"},{"location":"control/#performance-monitoring","title":"Performance Monitoring","text":"<p>Track control performance:</p> <pre><code>stats = controller.get_stats()\nprint(f\"Updates: {stats['updates']}\")\nprint(f\"Rate: {stats['update_rate_hz']:.1f} Hz\")\nprint(f\"Duration: {stats['elapsed_seconds']:.1f}s\")\n</code></pre>"},{"location":"control/#integration-with-rl-training","title":"Integration with RL Training","text":""},{"location":"control/#observation-action-loop","title":"Observation-Action Loop","text":"<pre><code>import gymnasium as gym\nfrom ac_bridge.telemetry.ac_native_memory import ACSharedMemory\nfrom ac_bridge.control import VJoyController\n\nclass ACEnv(gym.Env):\n    def __init__(self):\n        self.telemetry = ACSharedMemory()\n        self.controller = VJoyController()\n\n    def reset(self):\n        self.controller.reset()\n        return self._get_obs()\n\n    def step(self, action):\n        # Apply action\n        self.controller.set_controls(\n            throttle=action[0],\n            brake=action[1],\n            steering=action[2]\n        )\n\n        # Wait for physics update\n        time.sleep(0.016)  # 60 Hz\n\n        # Get new observation\n        obs = self._get_obs()\n        reward = self._compute_reward()\n        done = self._check_termination()\n\n        return obs, reward, done, {}\n\n    def _get_obs(self):\n        p = self.telemetry.physics\n        return [\n            p.speedKmh / 300.0,\n            p.steerAngle / 900.0,\n            p.heading,\n            # ... more features\n        ]\n</code></pre>"},{"location":"control/#cloud-training-setup","title":"Cloud Training Setup","text":"<p>See cloud_setup.md for bidirectional telemetry + control over WebSocket.</p>"},{"location":"control/#technical-details","title":"Technical Details","text":""},{"location":"control/#vjoy-axis-mapping","title":"vJoy Axis Mapping","text":"vJoy Axis Usage ID AC Control Range X HID_USAGE_X Steering 0x1 - 0x8000 Y HID_USAGE_Y Throttle 0x1 - 0x8000 Z HID_USAGE_Z Brake 0x1 - 0x8000 RZ HID_USAGE_RZ Clutch 0x1 - 0x8000 <p>Internal conversion: - Float 0.0 \u2192 vJoy 0x1 (min) - Float 0.5 \u2192 vJoy 0x4000 (center) - Float 1.0 \u2192 vJoy 0x8000 (max)</p>"},{"location":"control/#button-usage","title":"Button Usage","text":"<p>Buttons 1-8 can be mapped in AC for: - Gear up/down (sequential) - H-pattern gears (individual buttons) - DRS, KERS activation - Look left/right - Pit limiter</p>"},{"location":"control/#latency-measurement","title":"Latency Measurement","text":"<p>Test round-trip latency:</p> <pre><code>import time\n\ncontroller = VJoyController()\nasm = ACSharedMemory()\n\n# Measure control \u2192 telemetry latency\nstart = time.perf_counter()\ncontroller.set_throttle(1.0)\n\nwhile asm.physics.gas &lt; 0.9:\n    time.sleep(0.001)\n\nlatency_ms = (time.perf_counter() - start) * 1000\nprint(f\"Control latency: {latency_ms:.1f}ms\")\n</code></pre> <p>Typical results: 5-15ms (includes AC's input polling + physics update).</p>"},{"location":"control/#references","title":"References","text":"<ul> <li>vJoy Project: https://sourceforge.net/projects/vjoystick/</li> <li>pyvjoy Library: https://github.com/tidzo/pyvjoy</li> <li>Windows DirectInput API: https://docs.microsoft.com/en-us/windows/win32/directinput/</li> </ul>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#bridge-api-testing","title":"Bridge API Testing","text":""},{"location":"examples/#action-smoothing-test","title":"Action Smoothing Test","text":"<p>Test the action smoothing system with various configurations:</p> <pre><code># Start AC and enter a session, then:\nuv run examples/test_action_smoothing.py\n</code></pre> <p>This will demonstrate: - Moderate smoothing (default, recommended) - Aggressive smoothing (more responsive) - No smoothing (hard clamps only, jerky)</p> <p>See Action Smoothing for details.</p>"},{"location":"examples/#bridge-api-demo","title":"Bridge API Demo","text":"<p>Test the core <code>ACBridgeLocal</code> API:</p> <pre><code>uv run examples/test_bridge_api.py\n</code></pre> <p>Demonstrates: - Basic operations (connect, close) - Telemetry reading (latest_obs) - Control application (apply_action) - Session reset (reset) - Full Gym-style environment example</p>"},{"location":"examples/#control-testing","title":"Control Testing","text":"<p>Interactive control testing tool:</p> <pre><code>uv run examples/test_control.py\n</code></pre> <p>Use this to: - Test individual vJoy axes (steering, throttle, brake, clutch) - Map vJoy buttons in AC - Verify control latency - Debug stuck buttons (press 'r' to reset all controls)</p>"},{"location":"examples/#websocket-telemetry-streaming","title":"WebSocket Telemetry Streaming","text":""},{"location":"examples/#local-development-mode","title":"Local Development Mode","text":"<p>Start a WebSocket server on your local machine:</p> <pre><code>uv run main.py stream --host localhost --port 8765 --rate 10\n</code></pre> <p>Then connect with the example client:</p> <pre><code>uv run examples/websocket_client.py\n</code></pre> <p>This is useful for: - Local testing and development - Running Gymnasium environments on same machine - Quick prototyping</p>"},{"location":"examples/#cloud-training-mode","title":"Cloud Training Mode","text":"<p>Stream telemetry to a remote server (EC2, VPS, etc.):</p> <pre><code># On EC2: Start receiver\npython examples/cloud_server.py --host 0.0.0.0 --port 8765\n\n# On Windows: Connect and stream\nuv run main.py cloud --uri ws://your-ec2-ip:8765 --rate 10\n</code></pre> <p>This enables: - Cloud-based RL training with home AC setup - Training on GPU instances while playing at home - No port forwarding or VPN needed</p> <p>See Cloud Setup Guide for detailed instructions.</p>"},{"location":"examples/#custom-client","title":"Custom Client","text":"<p>You can create your own client in any language. Here's the basic structure:</p> <p>Python: <pre><code>import asyncio\nimport json\nimport websockets\n\nasync def receive():\n    async with websockets.connect(\"ws://localhost:8765\") as ws:\n        async for message in ws:\n            data = json.loads(message)\n            print(data['speed_kmh'], data['rpm'])\n\nasyncio.run(receive())\n</code></pre></p> <p>JavaScript/Node.js: <pre><code>const WebSocket = require('ws');\nconst ws = new WebSocket('ws://localhost:8765');\n\nws.on('message', (data) =&gt; {\n    const telemetry = JSON.parse(data);\n    console.log(telemetry.speed_kmh, telemetry.rpm);\n});\n</code></pre></p> <p>Python (Gymnasium Environment): <pre><code>import asyncio\nimport json\nimport websockets\nimport gymnasium as gym\n\nclass ACEnv(gym.Env):\n    async def connect(self):\n        self.ws = await websockets.connect(\"ws://localhost:8765\")\n\n    async def get_obs(self):\n        message = await self.ws.recv()\n        return json.loads(message)\n</code></pre></p>"},{"location":"examples/#data-format","title":"Data Format","text":"<p>Each message is a JSON object with the following structure:</p> <pre><code>{\n  \"timestamp\": 123,\n  \"packet_id\": 456789,\n  \"speed_kmh\": 145.3,\n  \"rpm\": 5420,\n  \"gear\": 3,\n  \"gas\": 0.85,\n  \"brake\": 0.00,\n  \"steer_angle\": -12.5,\n\n  \"velocity_x\": 35.2,\n  \"velocity_y\": 0.1,\n  \"velocity_z\": 15.8,\n\n  \"angular_velocity_x\": 0.05,\n  \"angular_velocity_y\": 0.12,\n  \"angular_velocity_z\": 0.02,\n\n  \"world_position_x\": 123.45,\n  \"world_position_y\": 10.2,\n  \"world_position_z\": 456.78,\n\n  \"yaw\": 1.57,\n  \"pitch\": 0.02,\n  \"roll\": 0.01,\n\n  \"wheel_slip\": [0.12, 0.15, 0.10, 0.13],\n  \"wheel_angular_speed\": [145.2, 147.1, 143.8, 146.5],\n  \"wheel_load\": [2500, 2450, 2300, 2350],\n\n  \"number_of_tyres_out\": 0,\n  \"is_lap_valid\": true,\n  \"bodywork_damaged\": false,\n  \"completed_laps\": 5,\n  \"distance_traveled\": 12543.2,\n  \"normalized_position\": 0.75,\n  ...\n}\n</code></pre> <p>See <code>docs/telemetry.md</code> for complete field descriptions.</p>"},{"location":"getting-started/","title":"Quick Start Guide","text":"<p>This guide will get you up and running with AC Bridge in 5 minutes.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<p>Before you start, make sure you have:</p> <ul> <li>\u2705 Windows 10/11</li> <li>\u2705 Python 3.11 or higher</li> <li>\u2705 Assetto Corsa (original, not Competizione)</li> <li>\u2705 vJoy virtual joystick driver installed</li> </ul>"},{"location":"getting-started/#installation","title":"Installation","text":"<pre><code># Clone the repository\ngit clone https://github.com/wongd-hub/assetto-corsa-gym.git\ncd assetto-corsa-gym\n\n# Install with uv (recommended)\nuv sync\nuv pip install -e .\n\n# Or with pip\npip install -e .\n</code></pre>"},{"location":"getting-started/#verify-installation","title":"Verify Installation","text":"<pre><code># Test telemetry reading (AC must be running)\nuv run ac-bridge test-telemetry --hz 10\n\n# Test vJoy control\nuv run ac-bridge test-control\n\n# Run smoke test (combines telemetry + control)\nuv run ac-bridge smoke-test\n</code></pre>"},{"location":"getting-started/#your-first-integration","title":"Your First Integration","text":"<p>Create a file <code>my_env.py</code>:</p> <pre><code>from ac_bridge import ACBridgeLocal, RealTimeStepper\nimport numpy as np\n\n# Initialize bridge\nbridge = ACBridgeLocal(\n    telemetry_hz=60,  # Background telemetry polling rate\n    control_hz=10      # RL step rate\n)\n\n# Create stepper for consistent timing\nstepper = RealTimeStepper(bridge, control_hz=10)\n\n# Connect to AC\nbridge.connect()\nprint(\"Connected to Assetto Corsa!\")\n\ntry:\n    # Reset (restarts race and shifts to 1st gear)\n    obs, info = stepper.reset()\n    print(f\"Initial observation shape: {obs.shape}\")\n    print(f\"Speed: {info['speed_kmh']:.1f} km/h\")\n\n    # Run for 100 steps\n    for step in range(100):\n        # Your policy would go here\n        # For now, just go straight with some throttle\n        action = np.array([0.0, 0.5, 0.0])  # [steer, throttle, brake]\n\n        # Apply action and get next observation\n        obs, info = stepper.step(action)\n\n        # Check what's happening\n        print(f\"Step {step}: Speed={info['speed_kmh']:.1f} km/h, \"\n              f\"RPM={info['rpm']}, Gear={info['gear']}\")\n\n        # Your reward/done logic would go here\n        if info['number_of_tyres_out'] &gt;= 3:\n            print(\"Off track! Resetting...\")\n            obs, info = stepper.reset()\n\nfinally:\n    bridge.close()\n    print(\"Bridge closed\")\n</code></pre> <p>Run it:</p> <pre><code># Start AC, enter a session, then:\npython my_env.py\n</code></pre>"},{"location":"getting-started/#what-just-happened","title":"What Just Happened?","text":"<ol> <li><code>ACBridgeLocal</code> - Created a bridge that:</li> <li>Polls AC shared memory at 60 Hz in background thread</li> <li>Caches latest telemetry for instant access</li> <li> <p>Applies control via vJoy with action smoothing</p> </li> <li> <p><code>RealTimeStepper</code> - Created a stepper that:</p> </li> <li>Enforces consistent 10 Hz timing (100ms per step)</li> <li>Applies action \u2192 waits \u2192 reads observation</li> <li> <p>Returns drift-corrected observations with timing metadata</p> </li> <li> <p><code>.reset()</code> - Triggered session restart:</p> </li> <li>Pressed vJoy button 7 (restart race)</li> <li>Waited 2s, pressed button 9 (start race)</li> <li>Reset controls, shifted to 1st gear</li> <li> <p>Returned initial observation</p> </li> <li> <p><code>.step(action)</code> - Applied action for 100ms:</p> </li> <li>Smoothed action (rate limiting + EMA)</li> <li>Applied to vJoy</li> <li>Waited until next 10 Hz tick</li> <li>Returned observation from that tick</li> </ol>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<p>Now that you have basic integration working:</p> <ol> <li>Wrap it in a Gym environment</li> <li>Understand action smoothing</li> <li>Explore telemetry fields</li> <li>Set up cloud training</li> </ol>"},{"location":"getting-started/#common-issues","title":"Common Issues","text":""},{"location":"getting-started/#vjoy-device-not-found","title":"\"vJoy device not found\"","text":"<p>Make sure vJoy is installed and device 1 is configured:</p> <pre><code># Test vJoy\nuv run ac-bridge test-control\n</code></pre>"},{"location":"getting-started/#ac-not-running-or-no-telemetry-available","title":"\"AC not running or no telemetry available\"","text":"<ol> <li>Start Assetto Corsa</li> <li>Enter a practice/race session (not main menu)</li> <li>Run your script</li> </ol>"},{"location":"getting-started/#controls-not-working-in-ac","title":"\"Controls not working in AC\"","text":"<p>Map vJoy device in AC's controls settings:</p> <ol> <li>AC \u2192 Options \u2192 Controls</li> <li>Select \"vJoy Device\"</li> <li>Map steering, throttle, brake axes</li> </ol>"},{"location":"getting-started/#timing-drift-inconsistent-step-rates","title":"\"Timing drift / inconsistent step rates\"","text":"<p>The <code>RealTimeStepper</code> handles this automatically. Check timing stats:</p> <pre><code>stats = stepper.get_stats()\nprint(f\"Avg step duration: {stats['avg_step_duration']:.3f}s\")\nprint(f\"Drift: {stats['avg_drift']:.3f}s\")\n</code></pre> <p>Drift should be &lt;1ms with default settings.</p>"},{"location":"getting-started/#example-scripts","title":"Example Scripts","text":"<p>Check out the <code>examples/</code> directory for more:</p> <ul> <li><code>test_bridge_api.py</code> - Complete API walkthrough</li> <li><code>test_action_smoothing.py</code> - Action smoothing demo</li> <li><code>test_timing.py</code> - Timing system validation</li> <li><code>test_control.py</code> - Interactive vJoy testing</li> </ul>"},{"location":"installation/","title":"Installation","text":"<p>Complete installation guide for AC Bridge.</p>"},{"location":"installation/#system-requirements","title":"System Requirements","text":"<ul> <li>OS: Windows 10/11 (64-bit)</li> <li>Python: 3.11 or higher</li> <li>Game: Assetto Corsa (original, not Competizione)</li> <li>Memory: 2GB+ RAM</li> <li>Disk: 500MB for dependencies</li> </ul>"},{"location":"installation/#step-1-install-python","title":"Step 1: Install Python","text":""},{"location":"installation/#option-a-microsoft-store-recommended","title":"Option A: Microsoft Store (Recommended)","text":"<pre><code># Search \"Python 3.11\" in Microsoft Store and install\n</code></pre>"},{"location":"installation/#option-b-pythonorg","title":"Option B: python.org","text":"<p>Download from python.org/downloads</p> <p>Verify installation:</p> <pre><code>python --version\n# Should show Python 3.11.x or higher\n</code></pre>"},{"location":"installation/#step-2-install-uv-optional-but-recommended","title":"Step 2: Install uv (Optional but Recommended)","text":"<p>uv is a fast Python package installer:</p> <pre><code># PowerShell (as Administrator)\npowershell -ExecutionPolicy ByPass -c \"irm https://astral.sh/uv/install.ps1 | iex\"\n</code></pre> <p>Restart your terminal, then verify:</p> <pre><code>uv --version\n</code></pre>"},{"location":"installation/#step-3-install-vjoy","title":"Step 3: Install vJoy","text":"<p>vJoy is required for sending control inputs to AC.</p> <ol> <li>Download vJoy 2.1.9</li> <li>Run installer</li> <li>Configure device 1:</li> <li>Open \"Configure vJoy\" from Start Menu</li> <li>Select \"Device 1\"</li> <li>Enable axes: X, Y, Z, RZ</li> <li>Enable 12 buttons</li> <li>Click \"Apply\"</li> </ol> <p>Verify in Windows Device Manager: - Devices and Printers \u2192 vJoy Device should appear</p>"},{"location":"installation/#step-4-install-ac-bridge","title":"Step 4: Install AC Bridge","text":""},{"location":"installation/#clone-repository","title":"Clone Repository","text":"<pre><code>git clone https://github.com/wongd-hub/assetto-corsa-gym.git\ncd assetto-corsa-gym\n</code></pre>"},{"location":"installation/#install-dependencies","title":"Install Dependencies","text":"<p>With uv (recommended):</p> <pre><code>uv sync\nuv pip install -e .\n</code></pre> <p>With pip:</p> <pre><code>pip install -e .\n</code></pre>"},{"location":"installation/#step-5-verify-installation","title":"Step 5: Verify Installation","text":""},{"location":"installation/#test-telemetry","title":"Test Telemetry","text":"<p>Start Assetto Corsa, enter a session, then:</p> <pre><code>uv run ac-bridge test-telemetry --hz 10\n</code></pre> <p>You should see live telemetry output:</p> <pre><code>Speed: 145 km/h | RPM: 5420 | Gear: 3 | Throttle: 85%\n</code></pre>"},{"location":"installation/#test-vjoy-control","title":"Test vJoy Control","text":"<pre><code>uv run ac-bridge test-control\n</code></pre> <p>Interactive menu should appear. Test each axis to verify vJoy is working.</p>"},{"location":"installation/#run-smoke-test","title":"Run Smoke Test","text":"<p>Combined test of telemetry + control:</p> <pre><code>uv run ac-bridge smoke-test\n</code></pre>"},{"location":"installation/#step-6-configure-ac-controls","title":"Step 6: Configure AC Controls","text":"<p>Map vJoy in Assetto Corsa:</p> <ol> <li>Launch AC \u2192 Options \u2192 Controls</li> <li>Change device to \"vJoy Device\"</li> <li>Map axes:</li> <li>Steering \u2192 vJoy X axis (Axle 1)</li> <li>Throttle \u2192 vJoy Y axis (Axle 2)</li> <li>Brake \u2192 vJoy Z axis (Axle 3)</li> <li> <p>Clutch \u2192 vJoy RZ axis (Axle 6, optional)</p> </li> <li> <p>Map buttons (recommended):</p> </li> </ol> vJoy Button Function Required for AC Bridge Button 1 Next gear No Button 2 Previous gear No Button 3 Brake balance \u2192 front No Button 4 Brake balance \u2192 rear No Button 5 Traction control + No Button 6 Traction control - No Button 7 Restart race Yes (for reset) Button 8 Restart session No Button 9 Start race Yes (for reset) <p>Required Buttons</p> <p>Buttons 7 and 9 must be mapped for <code>bridge.reset()</code> to work. The reset sequence presses button 7 (restart race), waits 2s, then presses button 9 (start race).</p> <ol> <li>Save and test - drive around to verify controls work</li> </ol>"},{"location":"installation/#troubleshooting","title":"Troubleshooting","text":""},{"location":"installation/#python-not-found","title":"Python not found","text":"<pre><code># Check Python is in PATH\npython --version\n\n# If not found, add to PATH:\n# Settings \u2192 System \u2192 About \u2192 Advanced system settings\n# \u2192 Environment Variables \u2192 Path \u2192 Add Python install dir\n</code></pre>"},{"location":"installation/#uv-not-recognized","title":"uv not recognized","text":"<pre><code># Restart terminal after installing uv\n# If still not working, add to PATH:\n%USERPROFILE%\\.cargo\\bin\n</code></pre>"},{"location":"installation/#vjoy-device-not-found","title":"vJoy device not found","text":"<pre><code># Check if vJoy is installed\nimport pyvjoy\ndevice = pyvjoy.VJoyDevice(1)  # Should not raise error\n</code></pre> <p>If error: 1. Reinstall vJoy 2. Configure device 1 in vJoy Configure tool 3. Reboot Windows</p>"},{"location":"installation/#modulenotfounderror","title":"ModuleNotFoundError","text":"<pre><code># Make sure you installed in editable mode\ncd assetto-corsa-gym\nuv pip install -e .\n\n# Or with pip\npip install -e .\n</code></pre>"},{"location":"installation/#ac-telemetry-not-available","title":"AC telemetry not available","text":"<p>Make sure: 1. AC is running (not just launcher) 2. You're in a session (practice/race, not main menu) 3. Shared memory is enabled (usually enabled by default)</p>"},{"location":"installation/#vjoy-controls-not-working-in-ac","title":"vJoy controls not working in AC","text":"<ol> <li>Check device in Windows Device Manager</li> <li>Test vJoy with <code>uv run ac-bridge test-control</code></li> <li>Re-map controls in AC (sometimes AC resets mappings)</li> <li>Make sure no other controller is active in AC</li> </ol>"},{"location":"installation/#optional-development-setup","title":"Optional: Development Setup","text":"<p>For contributing or modifying AC Bridge:</p> <pre><code># Install dev dependencies\nuv sync --dev\n\n# Install pre-commit hooks (optional)\npip install pre-commit\npre-commit install\n\n# Run tests\npytest\n\n# Build docs locally\nuv run mkdocs serve\n</code></pre>"},{"location":"installation/#next-steps","title":"Next Steps","text":"<ul> <li>\u2705 Installation complete!</li> <li>\ud83d\udcd6 Quick Start Guide</li> <li>\ud83d\ude80 Build your first integration</li> <li>\ud83d\udcda API Reference</li> </ul>"},{"location":"installation/#updating","title":"Updating","text":"<p>To update to the latest version:</p> <pre><code>cd assetto-corsa-gym\ngit pull\nuv sync  # or pip install -e .\n</code></pre> <p>Check the release notes for breaking changes.</p>"},{"location":"telemetry/","title":"Assetto Corsa Telemetry Parser","text":""},{"location":"telemetry/#overview","title":"Overview","text":"<p>This project reads real-time telemetry data from Assetto Corsa using shared memory. The telemetry system provides comprehensive car state information including physics, graphics, and static data at configurable rates (1-60 Hz).</p>"},{"location":"telemetry/#architecture","title":"Architecture","text":""},{"location":"telemetry/#shared-memory-approach","title":"Shared Memory Approach","text":"<p>Assetto Corsa exposes three memory-mapped files for telemetry access:</p> <ol> <li>acpmf_physics - Updated every physics tick (typically 333 Hz)</li> <li>Car dynamics (speed, acceleration, forces)</li> <li>Wheel data (slip, load, temperature)</li> <li>Engine state (RPM, gear, fuel)</li> <li> <p>Control inputs (gas, brake, steering)</p> </li> <li> <p>acpmf_graphics - Updated every graphics frame (typically 60-144 Hz)</p> </li> <li>Lap timing and position</li> <li>Track limits and penalties</li> <li>Session information</li> <li> <p>UI state</p> </li> <li> <p>acpmf_static - Updated on session change</p> </li> <li>Car specifications</li> <li>Track information</li> <li>Session configuration</li> </ol>"},{"location":"telemetry/#implementation","title":"Implementation","text":"<p>The native implementation uses Python's <code>mmap</code> and <code>ctypes</code> modules to map and read shared memory structures directly. This provides sub-millisecond latency access to telemetry data.</p>"},{"location":"telemetry/#sources-and-attribution","title":"Sources and Attribution","text":"<p>This implementation is based on research and code from:</p> <ul> <li>DIY-DirectDrive Project by JanBalke420</li> <li>Repository: https://github.com/JanBalke420/DIY-DirectDrive</li> <li>Provided native AC shared memory structure definitions</li> <li> <p>Used for primary implementation in <code>ac_native_memory.py</code></p> </li> <li> <p>ac-remote-telemetry-client by rickwest</p> </li> <li>Repository: https://github.com/rickwest/ac-remote-telemetry-client</li> <li>Reference for AC UDP protocol investigation</li> <li> <p>Note: UDP approach was not used in final implementation due to reliability issues</p> </li> <li> <p>CrewChiefV4 by mrbelowski</p> </li> <li>Repository: https://github.com/mrbelowski/CrewChiefV4</li> <li>Analyzed for AC UDP protocol implementation</li> <li>Confirmed UDP telemetry requires handshake/subscribe protocol</li> <li> <p>Note: UDP approach abandoned in favor of shared memory</p> </li> <li> <p>pyaccsharedmemory library</p> </li> <li>Python package for ACC/AC shared memory access</li> <li>Note: Initially explored but not used in final implementation due to limited compatibility with original AC</li> </ul>"},{"location":"telemetry/#why-shared-memory-instead-of-udp","title":"Why Shared Memory Instead of UDP","text":"<p>Initial development explored AC's UDP telemetry protocol based on references from ac-remote-telemetry-client and CrewChiefV4. The UDP approach was ultimately abandoned for the following reasons:</p> <ol> <li>Reliability Issues - UDP packets were inconsistently received even with proper handshake/subscribe implementation</li> <li>Protocol Complexity - Required maintaining bidirectional communication with handshake, subscription, and keepalive packets</li> <li>Port Conflicts - AC binds to port 9996 exclusively, preventing direct packet sniffing without relay software</li> <li>Session Dependency - Only works when actively driving, fails in menus or between sessions</li> <li>Latency - Even when working, UDP had higher and more variable latency than shared memory</li> </ol> <p>Shared memory provides: - Sub-millisecond read latency (&lt; 1ms vs 5-50ms for UDP) - 100% reliability (no dropped packets) - Simple implementation (single read operation, no protocol state machine) - Works regardless of AC's internal state - Direct access without intermediate relay software</p>"},{"location":"telemetry/#key-telemetry-fields","title":"Key Telemetry Fields","text":""},{"location":"telemetry/#track-limits-and-penalties","title":"Track Limits and Penalties","text":"<ul> <li><code>numberOfTyresOut</code> (int): Count of wheels off track (0-4)</li> <li>0: All wheels on track</li> <li>1-2: Minor cut (typically still valid)</li> <li> <p>3-4: Major cut (lap invalidated)</p> </li> <li> <p><code>is_lap_valid</code> (bool): Derived field tracking if current lap has been invalidated</p> </li> <li>Resets on lap completion</li> <li>Set to false when 3+ tyres go off track</li> </ul>"},{"location":"telemetry/#wheel-dynamics","title":"Wheel Dynamics","text":"<ul> <li><code>wheelSlip</code> (float[4]): Slip ratio per wheel [FL, FR, RL, RR]</li> <li>0.0: Perfect grip (wheel speed matches ground speed)</li> <li>0.1-0.2: Optimal slip for maximum grip</li> <li>0.5+: Significant loss of traction</li> <li> <p>1.0: Complete lock (braking) or spin (acceleration)</p> </li> <li> <p><code>wheel_lock_detected</code> (bool): Derived field combining brake pressure and wheel slip</p> </li> <li>True when brake &gt; 0.5 AND avg wheel slip &gt; 0.5</li> <li>Indicates wheels have stopped rotating but car is still moving</li> </ul>"},{"location":"telemetry/#damage-detection","title":"Damage Detection","text":"<ul> <li><code>carDamage</code> (float[5]): Body damage by section [front, rear, left, right, center]</li> <li>0.0: Pristine condition</li> <li>0.05-0.50: Minor to moderate damage</li> <li>0.50-1.0: Severe to destroyed</li> <li> <p>Derived fields: <code>bodywork_damaged</code> (&gt;5%), <code>bodywork_critical</code> (&gt;50%)</p> </li> <li> <p><code>tyreWear</code> (float[4]): Tire degradation per wheel [FL, FR, RL, RR]</p> </li> <li>0.0: New tire</li> <li>0.8: Significantly worn (grip reduction)</li> <li>0.95+: Critical wear (imminent failure)</li> <li>Derived fields: <code>tyre_damaged</code> (&gt;80%), <code>tyre_critical</code> (&gt;95%)</li> </ul>"},{"location":"telemetry/#lap-timing","title":"Lap Timing","text":"<ul> <li><code>completedLaps</code> (int): Number of completed laps</li> <li><code>iCurrentTime</code> (int): Current lap time in milliseconds (also <code>current_time</code>)</li> <li><code>iLastTime</code> (int): Previous lap time in milliseconds (also <code>last_time</code>)</li> <li><code>iBestTime</code> (int): Best lap time in session in milliseconds (also <code>best_time</code>)</li> <li><code>distance_traveled</code> (float): Total distance traveled in meters</li> <li><code>normalized_position</code> (float): Position on track (0.0-1.0, where 1.0 is one lap)</li> <li><code>current_sector_index</code> (int): Current track sector (0, 1, or 2)</li> </ul>"},{"location":"telemetry/#position-and-orientation","title":"Position and Orientation","text":"<ul> <li><code>velocity_x/y/z</code> (float): World-space velocity in m/s</li> <li><code>local_velocity_x/y/z</code> (float): Car-relative velocity [forward, up, right] in m/s</li> <li><code>world_position_x/y/z</code> (float): Car position in world coordinates</li> <li><code>yaw</code> (float): Car heading angle in radians (also available as <code>heading</code>)</li> <li><code>pitch</code> (float): Car pitch angle in radians</li> <li><code>roll</code> (float): Car roll angle in radians</li> <li><code>angular_velocity_x/y/z</code> (float): Rotation rates in rad/s [pitch rate, yaw rate, roll rate]</li> <li><code>acc_g_x/y/z</code> (float): G-forces in each axis</li> </ul>"},{"location":"telemetry/#wheel-data","title":"Wheel Data","text":"<ul> <li><code>wheel_slip</code> (float[4]): Slip ratio per wheel [FL, FR, RL, RR]</li> <li><code>wheel_angular_speed</code> (float[4]): Wheel rotation speed in rad/s</li> <li><code>wheel_load</code> (float[4]): Load on each wheel in Newtons</li> <li><code>wheel_pressure</code> (float[4]): Tire pressure per wheel</li> <li><code>suspension_travel</code> (float[4]): Suspension compression per wheel</li> </ul>"},{"location":"telemetry/#control-inputs","title":"Control Inputs","text":"<ul> <li><code>gas</code> (float): Throttle position 0.0-1.0</li> <li><code>brake</code> (float): Brake pressure 0.0-1.0</li> <li><code>clutch</code> (float): Clutch engagement 0.0-1.0</li> <li><code>steer_angle</code> (float): Steering wheel angle in degrees</li> </ul>"},{"location":"telemetry/#temperature-and-environment","title":"Temperature and Environment","text":"<ul> <li><code>brake_temp</code> (float[4]): Brake temperature per wheel in Celsius</li> <li><code>tyre_core_temp</code> (float[4]): Tire core temperature per wheel in Celsius</li> <li><code>air_temp</code> (float): Ambient air temperature in Celsius</li> <li><code>road_temp</code> (float): Track surface temperature in Celsius</li> </ul>"},{"location":"telemetry/#driver-assists","title":"Driver Assists","text":"<ul> <li><code>tc</code> (float): Traction control activation level 0.0-1.0</li> <li><code>abs_setting</code> (float): ABS configuration value (not activation level)</li> </ul>"},{"location":"telemetry/#usage","title":"Usage","text":""},{"location":"telemetry/#basic-telemetry-reading","title":"Basic Telemetry Reading","text":"<pre><code>uv run main.py read --rate 10\n</code></pre> <p>This outputs formatted telemetry at 10 Hz to the console.</p>"},{"location":"telemetry/#json-export-for-rl-training","title":"JSON Export for RL Training","text":"<pre><code>uv run main.py read --rate 10 --json-output telemetry.jsonl\n</code></pre> <p>This writes JSONL (JSON Lines) format data suitable for ingestion by reinforcement learning pipelines.</p>"},{"location":"telemetry/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"telemetry/#latency","title":"Latency","text":"<ul> <li>Shared memory read: &lt; 1ms</li> <li>Memory map overhead: ~50 microseconds</li> <li>Python struct unpacking: ~100 microseconds</li> <li>Total latency: &lt; 2ms for complete telemetry read</li> </ul>"},{"location":"telemetry/#update-rates","title":"Update Rates","text":"<ul> <li>Physics data: 333 Hz (AC internal physics rate)</li> <li>Graphics data: 60-144 Hz (varies with framerate)</li> <li>Recommended polling: 10-60 Hz for RL applications</li> <li>Maximum practical: 100 Hz (diminishing returns beyond this)</li> </ul>"},{"location":"telemetry/#memory-overhead","title":"Memory Overhead","text":"<ul> <li>Physics structure: 1,320 bytes</li> <li>Graphics structure: 1,580 bytes</li> <li>Static structure: ~5,000 bytes</li> <li>Total mapped: ~8 KB (minimal footprint)</li> </ul>"},{"location":"telemetry/#data-quality-notes","title":"Data Quality Notes","text":""},{"location":"telemetry/#original-ac-implementation","title":"Original AC Implementation","text":"<p>The native implementation targets original Assetto Corsa (not Competizione). Some fields have specific semantics in AC:</p> <ul> <li><code>abs</code> field represents ABS configuration setting, not real-time activation level</li> <li><code>isValidLap</code> not directly available (derived from <code>numberOfTyresOut</code>)</li> </ul>"},{"location":"telemetry/#field-reliability","title":"Field Reliability","text":"<p>Highly reliable fields: - Speed, RPM, gear, control inputs - Wheel slip, tire wear, damage - Lap times and lap count - numberOfTyresOut (most reliable track limit indicator)</p> <p>Less reliable fields: - Surface grip (track-dependent calibration) - Some penalty flags (inconsistent behavior) - ABS/TC activation (use derived metrics instead)</p>"},{"location":"telemetry/#websocket-streaming","title":"WebSocket Streaming","text":"<p>The telemetry system includes a WebSocket server for real-time data streaming. This enables integration with external processes, cloud training, and multi-language clients.</p>"},{"location":"telemetry/#architecture_1","title":"Architecture","text":"<pre><code>AC (Shared Memory) \u2192 Python Reader \u2192 WebSocket Server \u2192 Clients (Gym, Cloud, etc.)\n                        (10-60 Hz)      (Broadcast)       (Multiple)\n</code></pre>"},{"location":"telemetry/#server-implementation","title":"Server Implementation","text":"<p>The server runs two concurrent tasks: 1. Telemetry Loop - Reads from shared memory at configured rate 2. WebSocket Handler - Manages client connections and broadcasts</p> <p>Key characteristics: - Non-blocking async I/O using <code>asyncio</code> and <code>websockets</code> - Broadcast pattern (one-to-many) - Automatic client cleanup on disconnect - JSON serialization for language-agnostic integration</p>"},{"location":"telemetry/#client-connection","title":"Client Connection","text":"<p>Clients connect using standard WebSocket protocol:</p> <pre><code>import asyncio\nimport json\nimport websockets\n\nasync def receive():\n    async with websockets.connect(\"ws://localhost:8765\") as ws:\n        async for message in ws:\n            data = json.loads(message)\n            # Use telemetry data\n</code></pre>"},{"location":"telemetry/#message-format","title":"Message Format","text":"<p>Each message is a complete telemetry snapshot in JSON: - All fields from shared memory - Derived metrics (wheel_lock_detected, is_lap_valid, etc.) - Timestamp for synchronization</p> <p>Message rate matches server broadcast rate (1-60 Hz configurable).</p>"},{"location":"telemetry/#performance","title":"Performance","text":"<ul> <li>Server overhead: &lt; 1ms per broadcast</li> <li>JSON serialization: ~200 microseconds</li> <li>Network latency (localhost): &lt; 1ms</li> <li>Total latency: ~2-3ms from AC to client</li> </ul> <p>For remote connections, add network RTT to latency.</p>"},{"location":"telemetry/#compatibility-with-other-projects","title":"Compatibility with Other Projects","text":""},{"location":"telemetry/#assetto_corsa_gym-dataset","title":"assetto_corsa_gym Dataset","text":"<p>The telemetry output includes fields compatible with the assetto_corsa_gym project:</p> <ul> <li><code>angular_velocity_x/y/z</code> - Angular rotation rates</li> <li><code>world_position_x/y/z</code> - World coordinates</li> <li><code>velocity_x/y/z</code> - World-space velocity components</li> <li><code>distance_traveled</code> - Similar to LapDist</li> <li><code>yaw</code>, <code>roll</code>, <code>pitch</code> - Orientation</li> <li><code>packet_id</code> - Packet sequencing</li> <li><code>number_of_tyres_out</code> - Track limit detection (similar to out_of_track)</li> <li><code>steer_angle</code>, <code>gas</code>, <code>brake</code> - Control inputs</li> <li><code>rpm</code>, <code>gear</code> - Engine state</li> <li><code>completed_laps</code> - Lap count</li> </ul> <p>Additional physics data available: - <code>wheel_angular_speed</code> - Individual wheel rotation speeds - <code>wheel_load</code> - Load per wheel - <code>wheel_pressure</code> - Tire pressure - <code>suspension_travel</code> - Suspension compression</p>"},{"location":"telemetry/#integration-with-gymnasium","title":"Integration with Gymnasium","text":"<p>The telemetry data is structured for easy integration with Gymnasium environments:</p>"},{"location":"telemetry/#state-observation-space","title":"State Observation Space","text":"<p>Recommended fields for observation vector: - Speed, RPM, gear - Control inputs (gas, brake, steer) - Wheel slip (individual or average) - Position on track (normalizedCarPosition) - G-forces (lateral/longitudinal acceleration) - Tire wear and temperatures</p>"},{"location":"telemetry/#reward-shaping","title":"Reward Shaping","text":"<p>Useful fields for reward calculation: - <code>iCurrentTime</code> - Lap time improvement - <code>numberOfTyresOut</code> - Track limits penalty - <code>wheel_lock_detected</code> - Driving quality penalty - <code>tyreWear</code> - Tire management reward - <code>normalizedCarPosition</code> - Progress tracking</p>"},{"location":"telemetry/#termination-conditions","title":"Termination Conditions","text":"<p>Episode termination triggers: - <code>bodywork_critical</code> - Severe crash - <code>tyre_critical</code> - Catastrophic tire failure - <code>numberOfTyresOut &gt;= 4</code> - Complete off-track - Timeout (lap time exceeds threshold)</p>"},{"location":"telemetry/#technical-considerations","title":"Technical Considerations","text":""},{"location":"telemetry/#windows-memory-mapping","title":"Windows Memory Mapping","text":"<p>The shared memory implementation uses Windows-specific APIs via ctypes. Memory-mapped files are accessed via:</p> <pre><code>mmap.mmap(-1, size, tagname)\n</code></pre> <p>The <code>tagname</code> corresponds to AC's published memory handles: - \"acpmf_physics\" - \"acpmf_graphics\" - \"acpmf_static\"</p>"},{"location":"telemetry/#structure-packing","title":"Structure Packing","text":"<p>All structures use 4-byte alignment (<code>_pack_ = 4</code>) to match AC's memory layout. Incorrect packing will cause field misalignment and incorrect data reads.</p>"},{"location":"telemetry/#threading-and-synchronization","title":"Threading and Synchronization","text":"<p>AC updates shared memory asynchronously. No explicit locking is required as reads are atomic for aligned data types. However, consistency within a single read is not guaranteed across different memory sections (physics vs graphics).</p> <p>For RL applications, read all required data in a single pass and timestamp it, rather than making multiple reads across decision boundaries.</p>"},{"location":"advanced/cloud-setup/","title":"Cloud Setup Guide","text":""},{"location":"advanced/cloud-setup/#problem-nat-and-firewall","title":"Problem: NAT and Firewall","text":"<p>Your home Windows PC running AC is behind NAT/firewall, so cloud instances (EC2, etc.) cannot directly connect to it. The solution is to reverse the connection direction.</p>"},{"location":"advanced/cloud-setup/#solution-windows-dials-out-to-cloud","title":"Solution: Windows Dials OUT to Cloud","text":"<p>Have your Windows machine connect TO your cloud server. This works because: - Outbound connections are allowed through NAT - No port forwarding required on home router - No public IP needed on Windows machine - Works from anywhere (home, cafe, etc.)</p>"},{"location":"advanced/cloud-setup/#architecture","title":"Architecture","text":"<pre><code>Windows PC (AC + Bridge)  --&gt;  Cloud Server (EC2)  --&gt;  Training\n   Behind NAT                   Public IP               GPUs\n\nConnection flow:\n1. Cloud server starts WebSocket server on port 8765\n2. Windows bridge connects TO cloud server\n3. Bridge streams telemetry through persistent connection\n4. Training code receives telemetry in real-time\n</code></pre>"},{"location":"advanced/cloud-setup/#setup-steps","title":"Setup Steps","text":""},{"location":"advanced/cloud-setup/#1-cloud-server-setup-ec2","title":"1. Cloud Server Setup (EC2)","text":"<p>Launch EC2 Instance: <pre><code># Ubuntu 22.04 LTS recommended\n# Instance type: t3.medium or better\n# Storage: 20GB minimum\n</code></pre></p> <p>Configure Security Group: <pre><code>Inbound Rules:\n- Port 8765 (WebSocket): TCP from YOUR_HOME_IP/32\n- Port 22 (SSH): TCP from YOUR_HOME_IP/32\n</code></pre></p> <p>Install Dependencies: <pre><code># SSH into EC2\nssh -i your-key.pem ubuntu@your-ec2-ip\n\n# Install Python 3.11+\nsudo apt update\nsudo apt install python3.11 python3.11-venv python3-pip -y\n\n# Install websockets\npip3 install websockets\n</code></pre></p> <p>Start Receiver Server: <pre><code># Copy cloud_server.py to EC2\nscp -i your-key.pem examples/cloud_server.py ubuntu@your-ec2-ip:~/\n\n# Run server\npython3 cloud_server.py --host 0.0.0.0 --port 8765\n</code></pre></p>"},{"location":"advanced/cloud-setup/#2-windows-bridge-setup","title":"2. Windows Bridge Setup","text":"<p>Start Streaming to Cloud: <pre><code># On your Windows PC\nuv run main.py cloud --uri ws://YOUR_EC2_IP:8765 --rate 10\n</code></pre></p> <p>That's it! The bridge will: - Connect to your EC2 instance - Stream telemetry at 10 Hz - Auto-reconnect if connection drops - Continue streaming as long as AC is running</p>"},{"location":"advanced/cloud-setup/#3-test-connection","title":"3. Test Connection","text":"<p>On EC2 (watch for incoming data): <pre><code>python3 cloud_server.py --host 0.0.0.0 --port 8765\n\n# Should show:\n# [YOUR_IP:PORT] Client connected\n# [#10] Speed: 145.3 km/h | Lap: 2 | Valid: True\n# [#20] Speed: 152.1 km/h | Lap: 2 | Valid: True\n</code></pre></p> <p>On Windows (should show connection success): <pre><code>uv run main.py cloud --uri ws://YOUR_EC2_IP:8765 --rate 10\n\n# Should show:\n# connected_to_server uri=ws://YOUR_EC2_IP:8765\n# telemetry_stream_started rate_hz=10\n</code></pre></p>"},{"location":"advanced/cloud-setup/#secure-connection-recommended-for-production","title":"Secure Connection (Recommended for Production)","text":"<p>For production use, enable TLS:</p>"},{"location":"advanced/cloud-setup/#1-get-ssl-certificate","title":"1. Get SSL Certificate","text":"<pre><code># Install certbot on EC2\nsudo apt install certbot\n\n# Get certificate (requires domain name)\nsudo certbot certonly --standalone -d your-domain.com\n</code></pre>"},{"location":"advanced/cloud-setup/#2-run-server-with-tls","title":"2. Run Server with TLS","text":"<p>Modify <code>cloud_server.py</code> to use SSL:</p> <pre><code>import ssl\n\nssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\nssl_context.load_cert_chain('/etc/letsencrypt/live/your-domain.com/fullchain.pem',\n                            '/etc/letsencrypt/live/your-domain.com/privkey.pem')\n\nasync with websockets.serve(self.handler, self.host, self.port, ssl=ssl_context):\n    await asyncio.Future()\n</code></pre>"},{"location":"advanced/cloud-setup/#3-connect-with-wss","title":"3. Connect with WSS","text":"<pre><code>uv run main.py cloud --uri wss://your-domain.com:8765 --rate 10\n</code></pre>"},{"location":"advanced/cloud-setup/#firewall-configuration","title":"Firewall Configuration","text":""},{"location":"advanced/cloud-setup/#ec2-security-group","title":"EC2 Security Group","text":"<pre><code>Inbound:\n- Type: Custom TCP\n- Port: 8765\n- Source: YOUR_HOME_IP/32  # Restrict to your IP for security\n\nOutbound:\n- All traffic allowed (default)\n</code></pre>"},{"location":"advanced/cloud-setup/#windows-firewall","title":"Windows Firewall","text":"<p>No configuration needed - outbound connections are allowed by default.</p>"},{"location":"advanced/cloud-setup/#troubleshooting","title":"Troubleshooting","text":""},{"location":"advanced/cloud-setup/#connection-refused","title":"Connection Refused","text":"<pre><code>Error: connection_error error=[Errno 111] Connection refused\n</code></pre> <p>Fix: - Verify EC2 security group allows port 8765 from your IP - Verify cloud server is running - Check EC2 IP address is correct</p>"},{"location":"advanced/cloud-setup/#connection-timeout","title":"Connection Timeout","text":"<pre><code>Error: connection_error error=asyncio.exceptions.TimeoutError\n</code></pre> <p>Fix: - Verify EC2 instance is running - Check your home network allows outbound connections on port 8765 - Try using a different port (e.g., 443 or 80)</p>"},{"location":"advanced/cloud-setup/#auto-reconnect-not-working","title":"Auto-Reconnect Not Working","text":"<p>The bridge automatically reconnects every 5 seconds by default. Adjust:</p> <pre><code>uv run main.py cloud --uri ws://ec2-ip:8765 --reconnect-delay 10\n</code></pre>"},{"location":"advanced/cloud-setup/#high-latency","title":"High Latency","text":"<pre><code>Packet delays &gt; 100ms\n</code></pre> <p>Fix: - Choose EC2 region closer to your location - Reduce send rate: <code>--rate 5</code> instead of <code>--rate 10</code> - Check your home internet connection - Use wired connection instead of WiFi</p>"},{"location":"advanced/cloud-setup/#cost-optimization","title":"Cost Optimization","text":""},{"location":"advanced/cloud-setup/#ec2-instance-sizing","title":"EC2 Instance Sizing","text":"<ul> <li>Development: t3.micro ($0.01/hour)</li> <li>Training: p3.2xlarge ($3.06/hour with GPU)</li> <li>Use Spot Instances: Save 70% on training costs</li> </ul>"},{"location":"advanced/cloud-setup/#data-transfer-costs","title":"Data Transfer Costs","text":"<ul> <li>Telemetry: ~500 bytes/packet</li> <li>At 10 Hz: ~5 KB/s = 18 MB/hour = 432 MB/day</li> <li>EC2 data transfer out: First 100 GB/month free</li> <li>Cost: Minimal for telemetry alone</li> </ul>"},{"location":"advanced/cloud-setup/#alternative-use-existing-server","title":"Alternative: Use Existing Server","text":"<p>If you have a VPS or other cloud server:</p> <pre><code># Any Linux server with public IP\n# Install websockets: pip install websockets\n# Run cloud_server.py\npython3 cloud_server.py --host 0.0.0.0 --port 8765\n\n# Connect from Windows\nuv run main.py cloud --uri ws://your-vps-ip:8765\n</code></pre>"},{"location":"advanced/cloud-setup/#integration-with-training-code","title":"Integration with Training Code","text":"<p>The cloud server receives telemetry as JSON. Integrate with your RL training:</p> <pre><code>import asyncio\nimport json\nimport websockets\nfrom collections import deque\n\nclass TrainingReceiver:\n    def __init__(self):\n        self.buffer = deque(maxlen=1000)\n\n    async def handler(self, websocket):\n        async for message in websocket:\n            telemetry = json.loads(message)\n\n            # Add to buffer\n            self.buffer.append(telemetry)\n\n            # Process for training\n            if len(self.buffer) &gt;= 10:\n                obs = self.extract_observation(telemetry)\n                reward = self.calculate_reward(telemetry)\n                done = self.check_termination(telemetry)\n\n                # Feed to policy...\n\n    def extract_observation(self, t):\n        return [\n            t['speed_kmh'] / 300.0,  # Normalize\n            t['rpm'] / 8000.0,\n            t['yaw'],\n            t['angular_velocity_y'],\n            # ... more features\n        ]\n\n    def calculate_reward(self, t):\n        reward = 0.0\n        reward += t['speed_kmh'] * 0.01  # Progress reward\n        reward -= t['number_of_tyres_out'] * 10  # Off-track penalty\n        reward -= int(t['wheel_lock_detected']) * 5  # Lock penalty\n        return reward\n</code></pre>"},{"location":"advanced/cloud-setup/#next-steps","title":"Next Steps","text":"<ol> <li>Set up EC2 instance and start cloud_server.py</li> <li>Test connection from Windows with <code>main.py cloud</code></li> <li>Verify data is flowing (check cloud_server.py output)</li> <li>Integrate with your training pipeline</li> <li>Consider adding authentication for production use</li> </ol>"},{"location":"advanced/protocol/","title":"WebSocket Protocol","text":"<p>Advanced message protocol for cloud training and actor-learner setups.</p>"},{"location":"advanced/protocol/#message-types","title":"Message Types","text":"<pre><code>from ac_bridge.protocol import MessageType\n\nMessageType.TELEMETRY         # Single telemetry frame\nMessageType.TELEMETRY_BATCH   # Batch of frames (for compression)\nMessageType.CONTROL           # Single control command\nMessageType.CONTROL_BATCH     # Batch of commands (reduces RTT)\nMessageType.TRANSITION        # RL transition (s, a, r, s', done)\nMessageType.TRANSITION_BATCH  # Batch of transitions (actor\u2192learner)\nMessageType.WEIGHTS_UPDATE    # Neural network weights (learner\u2192actor)\nMessageType.PING / PONG       # Keep-alive heartbeat\n</code></pre>"},{"location":"advanced/protocol/#batching","title":"Batching","text":"<p>For cloud training, batching reduces network overhead:</p>"},{"location":"advanced/protocol/#without-batching-naive","title":"Without Batching (Naive)","text":"<pre><code># Send every frame individually\nfor frame in frames:\n    ws.send(encode(frame))  # 100 messages = 100 RTTs\n</code></pre>"},{"location":"advanced/protocol/#with-batching","title":"With Batching","text":"<pre><code># Accumulate and send batch\nbatch = []\nfor frame in frames:\n    batch.append(frame)\n    if len(batch) &gt;= 10:\n        ws.send(encode_batch(batch))  # 10 messages = 1 RTT\n        batch = []\n</code></pre> <p>Benefits: - 10x fewer network round-trips - Better compression (repeated field names) - Lower CPU overhead</p>"},{"location":"advanced/protocol/#actor-learner-pattern","title":"Actor-Learner Pattern","text":"<p>For distributed RL training:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510         \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502  Windows PC     \u2502         \u2502  Cloud (EC2)    \u2502\n\u2502  (Actor)        \u2502         \u2502  (Learner)      \u2502\n\u2502                 \u2502         \u2502                 \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502         \u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502 AC Bridge\u2502   \u2502  WiFi   \u2502  \u2502 PPO      \u2502   \u2502\n\u2502  \u2502 + Policy \u2502   \u2502\u25c4\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25ba\u2502  \u2502 Trainer  \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502         \u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2502                 \u2502         \u2502                 \u2502\n\u2502  - Read AC      \u2502         \u2502  - Train policy \u2502\n\u2502  - Run inference\u2502         \u2502  - Send weights \u2502\n\u2502  - Collect data \u2502         \u2502  - Store data   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518         \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Actor (Windows):</p> <pre><code>from ac_bridge import ACBridgeLocal, RealTimeStepper\nimport websockets\n\n# Local inference (fast)\nbridge = ACBridgeLocal(control_hz=10)\nstepper = RealTimeStepper(bridge, control_hz=10)\npolicy = load_policy()  # ONNX or TorchScript\n\nbridge.connect()\n\ntransitions = []\n\nasync with websockets.connect('ws://ec2-ip:8000') as ws:\n    obs, info = stepper.reset()\n\n    for step in range(1000):\n        # Local inference (no network delay!)\n        action = policy(obs)\n\n        # Apply action\n        next_obs, next_info = stepper.step(action)\n\n        # Collect transition\n        transition = Transition(\n            obs=obs,\n            action=action,\n            reward=compute_reward(next_obs, next_info),\n            next_obs=next_obs,\n            done=check_done(next_info),\n            info=next_info\n        )\n        transitions.append(transition)\n\n        # Send batch periodically\n        if len(transitions) &gt;= 100:\n            await ws.send(encode_batch(transitions))\n            transitions = []\n\n        # Receive new weights (async)\n        if ws.messages:\n            weights = await ws.recv()\n            policy.load_weights(weights)\n\n        obs = next_obs\n</code></pre> <p>Learner (Cloud):</p> <pre><code>import websockets\nfrom stable_baselines3 import PPO\n\npolicy = PPO(...)\n\nasync def handle_actor(ws, path):\n    while True:\n        # Receive transition batch\n        data = await ws.recv()\n        transitions = decode_batch(data, Transition)\n\n        # Add to replay buffer\n        for t in transitions:\n            replay_buffer.add(t)\n\n        # Train periodically\n        if len(replay_buffer) &gt;= 1000:\n            policy.train()\n\n            # Send new weights\n            weights = policy.get_weights()\n            await ws.send(encode(weights))\n\n# Run server\nasync with websockets.serve(handle_actor, '0.0.0.0', 8000):\n    await asyncio.Future()  # Run forever\n</code></pre>"},{"location":"advanced/protocol/#chunked-control","title":"Chunked Control","text":"<p>For high-latency connections, send control chunks:</p> <pre><code># Cloud sends 10 actions at once\ncontrol_batch = [\n    ControlCommand(steer=0.5, throttle=0.8, brake=0.0),\n    ControlCommand(steer=0.5, throttle=0.9, brake=0.0),\n    # ... 8 more\n]\nws.send(encode_batch(control_batch))\n\n# Windows executes them locally at 10 Hz\nfor cmd in control_batch:\n    bridge.apply_action(cmd.steer, cmd.throttle, cmd.brake)\n    time.sleep(0.1)\n\n# No network delay in control loop!\n</code></pre> <p>This converts \"per-step RTT\" into \"per-chunk RTT\".</p>"},{"location":"advanced/protocol/#compression","title":"Compression","text":"<p>MessagePack with gzip for large batches:</p> <pre><code>import msgpack\nimport gzip\n\ndef encode_batch(transitions):\n    packed = msgpack.packb(transitions)\n    compressed = gzip.compress(packed)\n    return compressed\n\n# Typical compression ratios:\n# JSON: 1.0x (baseline)\n# MessagePack: 0.4x\n# MessagePack + gzip: 0.15x\n</code></pre> <p>For 100-transition batch: - JSON: ~50KB - MessagePack: ~20KB - MessagePack+gzip: ~7KB</p>"},{"location":"advanced/protocol/#see-also","title":"See Also","text":"<ul> <li>Cloud Setup - EC2 deployment</li> <li>ACBridgeWSClient - WebSocket client API (TODO)</li> </ul>"},{"location":"api/action-smoothing/","title":"Action Smoothing","text":"<p>Action smoothing is critical for stable RL training at 10 Hz control rates.</p> <p>Without smoothing, policies produce jerky, unstable inputs that: - Cause spin-outs - Make training diverge - Produce unrealistic behavior</p> <p>With smoothing, you get: - Smooth, human-like inputs - Stable training - Faster convergence</p>"},{"location":"api/action-smoothing/#the-golden-rule","title":"The Golden Rule","text":"<p>Policy chooses targets, controller decides how fast to reach them.</p> <p>This separation is critical. The RL policy outputs target values, and the smoother gradually moves toward them.</p>"},{"location":"api/action-smoothing/#components","title":"Components","text":""},{"location":"api/action-smoothing/#1-rate-limiting-most-important","title":"1. Rate Limiting (Most Important)","text":"<p>Limits how much an input can change per timestep.</p> <p>Example (steering at 10 Hz): <pre><code>max_steer_delta = 0.15  # per step\n# This means: full lock in ~0.7 seconds\n</code></pre></p> <p>Different limits per control: - Steering: Small, smooth (0.10-0.15) - Throttle: Moderate (0.10 up, 0.25 down) - Brake: Fast application, slow release (0.30 up, 0.10 down)</p>"},{"location":"api/action-smoothing/#2-low-pass-filtering-ema-smoothing","title":"2. Low-Pass Filtering (EMA Smoothing)","text":"<p>Removes noisy outputs without lagging.</p> <pre><code>alpha = 0.6  # 0=full smoothing, 1=no smoothing\nsteer = alpha * target + (1 - alpha) * prev_steer\n</code></pre> <p>Typical values at 10 Hz: - Steering: 0.5-0.7 - Throttle: 0.6-0.8 - Brake: 0.6-0.8</p>"},{"location":"api/action-smoothing/#3-asymmetric-pedal-dynamics","title":"3. Asymmetric Pedal Dynamics","text":"<p>Models realistic human behavior: - Apply brake quickly, release slowly - Apply throttle smoothly, lift faster</p> <p>This alone stops 80% of spin-outs.</p>"},{"location":"api/action-smoothing/#4-hard-clamps-always-applied","title":"4. Hard Clamps (Always Applied)","text":"<p>Safety layer that always enforces: - Steering: [-1.0, 1.0] - Pedals: [0.0, 1.0]</p> <p>Never trust raw NN outputs.</p>"},{"location":"api/action-smoothing/#usage","title":"Usage","text":""},{"location":"api/action-smoothing/#default-recommended","title":"Default (Recommended)","text":"<pre><code>from ac_bridge import ACBridgeLocal\n\n# Moderate smoothing enabled by default\nbridge = ACBridgeLocal(telemetry_hz=60, control_hz=10)\nbridge.connect()\n\n# Smoothing happens automatically in apply_action()\nbridge.apply_action(steer=0.5, throttle=0.8, brake=0.0)\n</code></pre>"},{"location":"api/action-smoothing/#custom-config","title":"Custom Config","text":"<pre><code>from ac_bridge import ACBridgeLocal, SmoothingConfig\n\nconfig = SmoothingConfig(\n    enable_rate_limiting=True,\n    max_steer_delta=0.10,      # More conservative\n    enable_ema_smoothing=True,\n    steer_alpha=0.5            # More smoothing\n)\n\nbridge = ACBridgeLocal(\n    telemetry_hz=60,\n    control_hz=10,\n    smoothing_config=config\n)\n</code></pre>"},{"location":"api/action-smoothing/#presets","title":"Presets","text":"<pre><code>from ac_bridge import (\n    ACBridgeLocal,\n    get_conservative_config,  # Very smooth, human-like\n    get_moderate_config,      # Balanced (default)\n    get_aggressive_config,    # More responsive\n    get_no_smoothing_config   # Hard clamps only\n)\n\n# Conservative (good for initial training)\nbridge = ACBridgeLocal(\n    control_hz=10,\n    smoothing_config=get_conservative_config()\n)\n\n# No smoothing (not recommended for RL)\nbridge = ACBridgeLocal(\n    control_hz=10,\n    smoothing_config=get_no_smoothing_config()\n)\n</code></pre>"},{"location":"api/action-smoothing/#monitoring","title":"Monitoring","text":"<pre><code># Get smoothing statistics\nstats = bridge.get_smoother_stats()\n\nprint(f\"Steps: {stats['step_count']}\")\nprint(f\"Avg steer delta: {stats['avg_steer_delta']:.4f}\")\nprint(f\"Avg throttle delta: {stats['avg_throttle_delta']:.4f}\")\nprint(f\"Config: {stats['config']}\")\n</code></pre>"},{"location":"api/action-smoothing/#when-to-use-each-preset","title":"When to Use Each Preset","text":""},{"location":"api/action-smoothing/#conservative","title":"Conservative","text":"<ul> <li>When: Initial training, learning from scratch</li> <li>Why: Prevents catastrophic failures early on</li> <li>Trade-off: Slower reactions, less responsive</li> </ul>"},{"location":"api/action-smoothing/#moderate-default","title":"Moderate (Default)","text":"<ul> <li>When: General training, most use cases</li> <li>Why: Good balance of stability and responsiveness</li> <li>Trade-off: Minimal, recommended default</li> </ul>"},{"location":"api/action-smoothing/#aggressive","title":"Aggressive","text":"<ul> <li>When: Fine-tuning advanced policies, racing</li> <li>Why: More responsive, closer to expert behavior</li> <li>Trade-off: Requires stable policy to avoid spin-outs</li> </ul>"},{"location":"api/action-smoothing/#no-smoothing","title":"No Smoothing","text":"<ul> <li>When: Debugging, analyzing raw policy outputs</li> <li>Why: See what the policy actually wants to do</li> <li>Trade-off: Unstable, jerky, not suitable for training</li> </ul>"},{"location":"api/action-smoothing/#testing","title":"Testing","text":"<p>Run the smoothing test to see the difference:</p> <pre><code># Start AC and enter a session, then:\nuv run examples/test_action_smoothing.py\n</code></pre> <p>This will: 1. Test moderate smoothing (default) 2. Test aggressive smoothing 3. Test no smoothing (you'll see the difference!)</p>"},{"location":"api/action-smoothing/#implementation-details","title":"Implementation Details","text":"<p>The <code>ActionSmoother</code> class is integrated into <code>ACBridgeLocal.apply_action()</code>:</p> <ol> <li>Phase 0: Hard clamp inputs (always)</li> <li>Phase 1: Apply rate limiting (if enabled)</li> <li>Phase 2: Apply EMA smoothing (if enabled)</li> <li>Phase 3: Final safety clamps (always)</li> </ol> <p>State is automatically reset when <code>bridge.reset()</code> is called.</p>"},{"location":"api/action-smoothing/#performance","title":"Performance","text":"<p>Smoothing adds negligible overhead: - Rate limiting: Simple clipping, ~0.01ms - EMA filtering: Single multiply-add, ~0.01ms - Total: &lt;0.05ms per action</p> <p>This is insignificant compared to vJoy update latency (3-8ms).</p>"},{"location":"api/action-smoothing/#references","title":"References","text":"<ul> <li>Soft Actor-Critic - Action smoothing improves sample efficiency</li> <li>DDPG - Exploration noise vs. output smoothing</li> <li>TD3 - Target policy smoothing</li> </ul>"},{"location":"api/action-smoothing/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>Always use smoothing for RL training</li> <li>Start with moderate config</li> <li>Monitor avg_steer_delta - should be &lt;0.15 at 10 Hz</li> <li>Don't trust raw NN outputs - always clamp and smooth</li> <li>Smoothing \u2260 lag - EMA with alpha=0.6 is responsive</li> </ol> <p>Without smoothing, RL training in racing simulators is nearly impossible at low control rates (10 Hz).</p>"},{"location":"api/bridge-local/","title":"ACBridgeLocal API","text":"<p><code>ACBridgeLocal</code> is the main interface for interacting with Assetto Corsa on the same machine.</p>"},{"location":"api/bridge-local/#overview","title":"Overview","text":"<pre><code>from ac_bridge import ACBridgeLocal\n\nbridge = ACBridgeLocal(\n    telemetry_hz=60,       # Background telemetry polling rate\n    control_hz=10,          # Target RL step rate\n    controller=\"vjoy\",      # Controller type (only \"vjoy\" currently)\n    device_id=1,            # vJoy device ID\n    obs_dim=15,             # Observation vector dimension\n    smoothing_config=None   # Action smoothing config (None = moderate default)\n)\n</code></pre>"},{"location":"api/bridge-local/#architecture","title":"Architecture","text":"<pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502         ACBridgeLocal                    \u2502\n\u2502                                          \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502  Background Telemetry Thread     \u2502   \u2502\n\u2502  \u2502  - Polls AC shared memory @ 60Hz \u2502   \u2502\n\u2502  \u2502  - Enriches with timing metadata \u2502   \u2502\n\u2502  \u2502  - Caches latest snapshot        \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2502                                          \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\n\u2502  \u2502  Main Thread                      \u2502   \u2502\n\u2502  \u2502  - latest_obs() \u2192 instant read   \u2502   \u2502\n\u2502  \u2502  - apply_action() \u2192 smoothed     \u2502   \u2502\n\u2502  \u2502  - reset() \u2192 session restart     \u2502   \u2502\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api/bridge-local/#methods","title":"Methods","text":""},{"location":"api/bridge-local/#connect","title":"<code>connect()</code>","text":"<p>Starts the bridge:</p> <ul> <li>Spawns background telemetry polling thread</li> <li>Initializes vJoy controller</li> <li>Verifies AC shared memory is accessible</li> </ul> <pre><code>bridge.connect()\n# Raises RuntimeError if AC is not running\n</code></pre>"},{"location":"api/bridge-local/#close","title":"<code>close()</code>","text":"<p>Cleanly shuts down the bridge:</p> <ul> <li>Stops telemetry thread</li> <li>Resets vJoy controls to neutral</li> <li>Releases resources</li> </ul> <pre><code>bridge.close()\n# Always call this when done\n</code></pre>"},{"location":"api/bridge-local/#latest_obs-tuplenpndarray-dict","title":"<code>latest_obs() -&gt; tuple[np.ndarray, dict]</code>","text":"<p>Returns the latest cached telemetry observation.</p> <p>Returns:</p> <ul> <li><code>obs</code> (np.ndarray): Normalized 15-dim observation vector</li> <li><code>info</code> (dict): Full telemetry dict with 40+ fields</li> </ul> <p>Observation Vector (15-dim):</p> <pre><code>[\n    speed_normalized,      # 0-1 (0-300 km/h)\n    rpm_normalized,        # 0-1 (0-8000 RPM)\n    gear_normalized,       # 0-1 (0-6)\n    steering_angle_norm,   # -1 to 1\n    throttle,              # 0-1\n    brake,                 # 0-1\n    avg_wheel_slip,        # 0-1\n    body_damage_norm,      # 0-1\n    avg_tyre_wear,         # 0-1\n    lateral_accel,         # -1 to 1 (\u00b13g)\n    longitudinal_accel,    # -1 to 1 (\u00b13g)\n    yaw_rate,              # -1 to 1\n    track_position,        # 0-1 (normalized lap distance)\n    tyres_out_norm,        # 0-1 (0-4 tyres)\n    velocity_y_norm        # -1 to 1 (vertical velocity)\n]\n</code></pre> <p>Info Dict Fields:</p> <p>See Telemetry System for complete field list.</p> <p>Timing Metadata:</p> <p>Every observation includes:</p> <pre><code>info['seq']         # Sequence number\ninfo['t_wall']      # Wall clock time (perf_counter)\ninfo['dt']          # Target dt (e.g., 0.1s for 10 Hz)\ninfo['dt_actual']   # Actual time since last frame\n</code></pre> <p>Example:</p> <pre><code>obs, info = bridge.latest_obs()\n\nprint(f\"Speed: {info['speed_kmh']:.1f} km/h\")\nprint(f\"Observation shape: {obs.shape}\")  # (15,)\nprint(f\"Seq: {info['seq']}, dt: {info['dt_actual']:.3f}s\")\n</code></pre>"},{"location":"api/bridge-local/#apply_actionsteer-throttle-brake-clutch00","title":"<code>apply_action(steer, throttle, brake, clutch=0.0)</code>","text":"<p>Applies control action to vJoy with optional smoothing.</p> <p>Args:</p> <ul> <li><code>steer</code> (float): -1.0 (left) to 1.0 (right)</li> <li><code>throttle</code> (float): 0.0 to 1.0</li> <li><code>brake</code> (float): 0.0 to 1.0</li> <li><code>clutch</code> (float): 0.0 to 1.0 (optional)</li> </ul> <p>Smoothing (enabled by default):</p> <ol> <li>Rate limiting (max delta per step)</li> <li>EMA filtering (removes noise)</li> <li>Asymmetric pedal dynamics</li> <li>Hard clamps (safety)</li> </ol> <p>See Action Smoothing for details.</p> <p>Example:</p> <pre><code># Raw policy output (can be noisy/jerky)\nraw_action = policy(obs)  # e.g., [0.8, 1.0, 0.0]\n\n# Bridge applies smoothing automatically\nbridge.apply_action(\n    steer=raw_action[0],\n    throttle=raw_action[1],\n    brake=raw_action[2]\n)\n</code></pre>"},{"location":"api/bridge-local/#resetwait_time50-none","title":"<code>reset(wait_time=5.0) -&gt; None</code>","text":"<p>Triggers full session restart sequence:</p> <ol> <li>Press vJoy button 7 (restart race)</li> <li>Wait 2 seconds</li> <li>Press vJoy button 9 (start race)</li> <li>Wait remaining time</li> <li>Reset all controls to neutral</li> <li>Shift to 1st gear</li> <li>Reset smoother state</li> <li>Reset telemetry ticker</li> </ol> <p>Args:</p> <ul> <li><code>wait_time</code> (float): Total wait time after button 7 press (default: 5s)</li> </ul> <p>Example:</p> <pre><code>bridge.reset(wait_time=3.0)  # Faster reset\n# AC will restart race and be ready after 3 seconds\n</code></pre> <p>Button Requirements:</p> <p>Buttons 7 and 9 must be mapped in AC's controls:</p> Button Mapping Purpose Button 7 Restart race Triggers session restart Button 9 Start race Starts race after restart <p>See Control System - Button Mappings for complete setup guide.</p>"},{"location":"api/bridge-local/#get_smoother_stats-dict","title":"<code>get_smoother_stats() -&gt; dict</code>","text":"<p>Returns action smoothing statistics.</p> <p>Returns:</p> <pre><code>{\n    'step_count': 1000,\n    'avg_steer_delta': 0.087,\n    'avg_throttle_delta': 0.045,\n    'avg_brake_delta': 0.032,\n    'config': {\n        'rate_limiting': True,\n        'ema_smoothing': True,\n        'max_steer_delta': 0.15\n    }\n}\n</code></pre> <p>Empty dict <code>{}</code> if smoothing is disabled.</p>"},{"location":"api/bridge-local/#usage-patterns","title":"Usage Patterns","text":""},{"location":"api/bridge-local/#pattern-1-direct-use-manual-stepping","title":"Pattern 1: Direct Use (Manual Stepping)","text":"<pre><code>bridge = ACBridgeLocal(control_hz=10)\nbridge.connect()\n\nfor step in range(1000):\n    obs, info = bridge.latest_obs()\n    action = policy(obs)\n    bridge.apply_action(*action)\n    time.sleep(0.1)  # Manual 10 Hz timing\n\nbridge.close()\n</code></pre>"},{"location":"api/bridge-local/#pattern-2-with-realtimestepper-recommended","title":"Pattern 2: With RealTimeStepper (Recommended)","text":"<pre><code>from ac_bridge import ACBridgeLocal, RealTimeStepper\n\nbridge = ACBridgeLocal(control_hz=10)\nstepper = RealTimeStepper(bridge, control_hz=10)\n\nbridge.connect()\n\nobs, info = stepper.reset()\nfor step in range(1000):\n    action = policy(obs)\n    obs, info = stepper.step(action)  # Automatic timing\n\nbridge.close()\n</code></pre> <p>See RealTimeStepper for details.</p>"},{"location":"api/bridge-local/#pattern-3-gymnasium-environment","title":"Pattern 3: Gymnasium Environment","text":"<pre><code>import gymnasium as gym\nfrom ac_bridge import ACBridgeLocal, RealTimeStepper\n\nclass ACEnv(gym.Env):\n    def __init__(self):\n        super().__init__()\n        self.bridge = ACBridgeLocal(control_hz=10)\n        self.stepper = RealTimeStepper(self.bridge, control_hz=10)\n\n        self.observation_space = gym.spaces.Box(\n            low=-1, high=1, shape=(15,), dtype=np.float32\n        )\n        self.action_space = gym.spaces.Box(\n            low=np.array([-1, 0, 0]),\n            high=np.array([1, 1, 1]),\n            dtype=np.float32\n        )\n\n    def reset(self, **kwargs):\n        if not self.bridge.is_connected:\n            self.bridge.connect()\n        obs, self.info = self.stepper.reset()\n        return obs, self.info\n\n    def step(self, action):\n        obs, self.info = self.stepper.step(action)\n        reward = self._compute_reward(obs, self.info)\n        done = self._check_done(self.info)\n        truncated = False\n        return obs, reward, done, truncated, self.info\n\n    def close(self):\n        self.bridge.close()\n</code></pre>"},{"location":"api/bridge-local/#configuration","title":"Configuration","text":""},{"location":"api/bridge-local/#telemetry-rate","title":"Telemetry Rate","text":"<pre><code># Higher rate = more responsive, more CPU\nbridge = ACBridgeLocal(telemetry_hz=120)  # 120 Hz polling\n\n# Lower rate = less CPU, slightly delayed\nbridge = ACBridgeLocal(telemetry_hz=30)   # 30 Hz polling\n</code></pre> <p>Recommendation: 60 Hz is a good balance for 10 Hz RL.</p>"},{"location":"api/bridge-local/#control-rate","title":"Control Rate","text":"<pre><code># Slower RL steps = more exploration\nbridge = ACBridgeLocal(control_hz=5)   # 5 Hz (200ms per step)\n\n# Faster RL steps = more reactive\nbridge = ACBridgeLocal(control_hz=20)  # 20 Hz (50ms per step)\n</code></pre> <p>Recommendation: 10 Hz is standard for racing RL.</p>"},{"location":"api/bridge-local/#action-smoothing","title":"Action Smoothing","text":"<pre><code>from ac_bridge import get_aggressive_config, get_no_smoothing_config\n\n# More responsive (advanced policies)\nbridge = ACBridgeLocal(smoothing_config=get_aggressive_config())\n\n# Disable smoothing (debugging only)\nbridge = ACBridgeLocal(smoothing_config=get_no_smoothing_config())\n</code></pre> <p>See Action Smoothing for all options.</p>"},{"location":"api/bridge-local/#thread-safety","title":"Thread Safety","text":"<p><code>ACBridgeLocal</code> is thread-safe for reading telemetry:</p> <ul> <li>\u2705 Multiple threads can call <code>latest_obs()</code> simultaneously</li> <li>\u2705 Telemetry polling runs in background thread</li> <li>\u274c Only one thread should call <code>apply_action()</code> (control is not thread-safe)</li> </ul>"},{"location":"api/bridge-local/#performance","title":"Performance","text":"<p>Typical latencies on modern hardware:</p> <ul> <li><code>latest_obs()</code>: &lt;0.1ms (reads cached snapshot)</li> <li><code>apply_action()</code>: 3-8ms (vJoy + smoothing)</li> <li>Background telemetry: ~0.5ms per poll @ 60 Hz</li> </ul> <p>Total RL step overhead: ~5-10ms</p>"},{"location":"api/bridge-local/#error-handling","title":"Error Handling","text":"<pre><code># AC not running\ntry:\n    bridge.connect()\nexcept RuntimeError as e:\n    print(f\"AC not running: {e}\")\n\n# vJoy error (recovers automatically)\nbridge.apply_action(0.5, 1.0, 0.0)\n# Logs warning but doesn't crash\n\n# Clean shutdown\ntry:\n    # ... training loop ...\nfinally:\n    bridge.close()  # Always close\n</code></pre>"},{"location":"api/bridge-local/#see-also","title":"See Also","text":"<ul> <li>RealTimeStepper - For consistent RL timing</li> <li>Action Smoothing - Smoothing configuration</li> <li>Telemetry System - Field descriptions</li> </ul>"},{"location":"api/overview/","title":"AC Bridge API Reference","text":"<p>Comprehensive but concise reference for the ac-bridge Python API.</p>"},{"location":"api/overview/#core-classes","title":"Core Classes","text":""},{"location":"api/overview/#acbridgelocal","title":"ACBridgeLocal","text":"<p>Main bridge for same-machine RL training. Polls AC telemetry in background thread, exposes latest frame via thread-safe cache.</p> <pre><code>from ac_bridge import ACBridgeLocal\n\nbridge = ACBridgeLocal(\n    telemetry_hz=60,   # Background polling rate\n    control_hz=10,     # Target step rate (for stepper)\n    controller=\"vjoy\", # Controller type\n    device_id=1,       # vJoy device ID\n    obs_dim=15         # Observation vector dimension\n)\n</code></pre> <p>Methods:</p> <ul> <li><code>connect()</code> - Start telemetry thread, wait for first frame</li> <li><code>close()</code> - Stop threads, cleanup resources</li> <li><code>is_connected()</code> - Check if telemetry available</li> <li><code>latest_obs() -&gt; (obs, info)</code> - Get cached latest frame (instant, non-blocking)</li> <li><code>apply_action(steer, throttle, brake, clutch=0.0)</code> - Send control to vJoy</li> <li><code>reset(wait_time=5.0)</code> - Restart session (buttons 7+9), reset controls, shift to 1st</li> </ul> <p>Observation Format:</p> <p>15-dim normalized float32 array: <pre><code>[0] speed (0-300 km/h \u2192 0-1)\n[1-3] velocity x/y/z\n[4-6] throttle/brake/steerAngle\n[7-8] rpm/gear\n[9-11] g-forces (lateral/longitudinal/vertical)\n[12] avg wheel slip\n[13] tyres out (0-4 \u2192 0-1)\n[14] damage indicator (binary)\n</code></pre></p> <p>Info Dict Fields:</p> <p>Timing: <code>seq</code>, <code>t_wall</code>, <code>dt</code>, <code>dt_actual</code> Driving: <code>speed_kmh</code>, <code>rpm</code>, <code>gear</code>, <code>throttle</code>, <code>brake</code>, <code>steer_angle</code> Position: <code>position</code>, <code>velocity</code>, <code>local_velocity</code>, <code>angular_velocity</code> Track: <code>tyres_out</code>, <code>is_valid_lap</code>, <code>completed_laps</code>, <code>current_time</code>, <code>distance_traveled</code> Damage: <code>car_damage</code>, <code>bodywork_damaged</code>, <code>bodywork_critical</code>, <code>tyre_wear</code>, <code>tyre_damaged</code> Environment: <code>surface_grip</code>, <code>air_temp</code>, <code>road_temp</code>, <code>is_in_pit_lane</code></p>"},{"location":"api/overview/#realtimestepper","title":"RealTimeStepper","text":"<p>Enforces consistent step timing for RL. Wraps ACBridgeLocal with drift-correcting ticker.</p> <pre><code>from ac_bridge import ACBridgeLocal, RealTimeStepper\n\nbridge = ACBridgeLocal(telemetry_hz=60, control_hz=10)\nstepper = RealTimeStepper(bridge, control_hz=10)\nbridge.connect()\n</code></pre> <p>Methods:</p> <ul> <li><code>step(action) -&gt; (obs, info)</code> - Apply action, wait for tick, return observation</li> <li><code>reset() -&gt; (obs, info)</code> - Trigger session reset, return initial observation</li> <li><code>get_stats()</code> - Get timing statistics</li> </ul> <p>Action Format:</p> <p>numpy array: <code>[steer, throttle, brake]</code> or <code>[steer, throttle, brake, clutch]</code> - steer: -1.0 (left) to 1.0 (right) - throttle/brake/clutch: 0.0 to 1.0</p>"},{"location":"api/overview/#ticker","title":"Ticker","text":"<p>Drift-correcting frequency generator. Maintains precise timing over long runs.</p> <pre><code>from ac_bridge import Ticker\n\nticker = Ticker(hz=10)  # 10 Hz = 0.1s steps\nfor seq, t_wall, dt, dt_actual in ticker:\n    # Execute at precise 10 Hz\n    process_step()\n</code></pre> <p>Methods:</p> <ul> <li><code>tick() -&gt; (seq, t_wall, dt, dt_actual)</code> - Yield next tick</li> <li><code>reset(start_seq=0)</code> - Reset ticker for new episode</li> <li><code>get_stats()</code> - Get drift and jitter statistics</li> </ul>"},{"location":"api/overview/#protocol-types","title":"Protocol Types","text":""},{"location":"api/overview/#telemetryframe","title":"TelemetryFrame","text":"<pre><code>from ac_bridge.protocol import TelemetryFrame\n\nframe = TelemetryFrame(\n    seq=42,\n    t_wall=123.456,\n    dt=0.1,\n    dt_actual=0.0987,\n    obs=np.array([...]),\n    info={...}\n)\n</code></pre>"},{"location":"api/overview/#controlcommand","title":"ControlCommand","text":"<pre><code>from ac_bridge.protocol import ControlCommand\n\ncmd = ControlCommand(\n    seq=42,\n    steer=0.2,\n    throttle=0.8,\n    brake=0.0,\n    clutch=0.0\n)\n</code></pre>"},{"location":"api/overview/#codec","title":"Codec","text":"<p>Encode/decode messages (JSON or MessagePack):</p> <pre><code>from ac_bridge.protocol import Message, Codec\n\nmsg = Message(type=MessageType.TELEMETRY, payload={...})\nbytes_data = Codec.encode(msg, format='json')  # or 'msgpack'\ndecoded = Codec.decode(bytes_data, format='json')\n</code></pre>"},{"location":"api/overview/#usage-patterns","title":"Usage Patterns","text":""},{"location":"api/overview/#pattern-1-basic-training-loop","title":"Pattern 1: Basic Training Loop","text":"<pre><code>from ac_bridge import ACBridgeLocal\n\nbridge = ACBridgeLocal(telemetry_hz=60, control_hz=10)\nbridge.connect()\n\nfor episode in range(1000):\n    bridge.reset()  # Restart session\n\n    for step in range(100):\n        obs, info = bridge.latest_obs()\n        action = policy(obs)  # Your RL policy\n        bridge.apply_action(*action)\n        time.sleep(0.1)  # 10 Hz\n\nbridge.close()\n</code></pre>"},{"location":"api/overview/#pattern-2-gym-environment-recommended","title":"Pattern 2: Gym Environment (Recommended)","text":"<pre><code>from ac_bridge import ACBridgeLocal, RealTimeStepper\nimport gymnasium as gym\n\nclass AssettoCorsa_v0(gym.Env):\n    def __init__(self):\n        self.bridge = ACBridgeLocal(telemetry_hz=60, control_hz=10)\n        self.stepper = RealTimeStepper(self.bridge, control_hz=10)\n        self.bridge.connect()\n\n        self.observation_space = gym.spaces.Box(-1, 1, (15,), np.float32)\n        self.action_space = gym.spaces.Box(\n            np.array([-1, 0, 0]), np.array([1, 1, 1]), np.float32\n        )\n\n    def reset(self, seed=None, options=None):\n        super().reset(seed=seed)\n        obs, info = self.stepper.reset()\n        return obs, info\n\n    def step(self, action):\n        obs, info = self.stepper.step(action)  # Handles timing\n        reward = self._compute_reward(obs, info)\n        done = self._is_done(info)\n        return obs, reward, done, False, info\n\n    def _compute_reward(self, obs, info):\n        reward = info['speed_kmh'] / 100.0\n        if info['tyres_out'] &gt; 2:\n            reward -= 10.0\n        return reward\n\n    def _is_done(self, info):\n        return info['tyres_out'] &gt;= 4 or info['bodywork_critical']\n\n    def close(self):\n        self.bridge.close()\n</code></pre>"},{"location":"api/overview/#pattern-3-cloud-training-actor-learner","title":"Pattern 3: Cloud Training (Actor-Learner)","text":"<pre><code># Windows (actor)\nfrom ac_bridge import ACBridgeLocal\n\nbridge = ACBridgeLocal(telemetry_hz=60, control_hz=10)\nbridge.connect()\n\nwhile training:\n    obs, info = bridge.latest_obs()\n    action = local_policy(obs)  # Inference locally\n    bridge.apply_action(*action)\n\n    # Batch transitions and send to cloud\n    transitions.append((obs, action, reward, next_obs, done))\n    if len(transitions) &gt;= 100:\n        send_to_cloud(transitions)\n        transitions.clear()\n</code></pre>"},{"location":"api/overview/#performance","title":"Performance","text":"<ul> <li>Telemetry polling: 60 Hz background thread</li> <li>Control latency: 3-8ms (vJoy)</li> <li>Step timing accuracy: &lt;1ms drift over 1000 steps</li> <li>Observation overhead: ~0.1ms (cached)</li> </ul>"},{"location":"api/overview/#error-handling","title":"Error Handling","text":"<pre><code>bridge = ACBridgeLocal()\nbridge.connect()\n\ntry:\n    obs, info = bridge.latest_obs()\nexcept RuntimeError:\n    # AC not connected or no telemetry available\n    pass\n\n# Always cleanup\nbridge.close()\n</code></pre>"},{"location":"api/overview/#cli-commands","title":"CLI Commands","text":"<p>Quick reference for terminal usage:</p> <pre><code># Main bridge loop (monitoring)\nuv run ac-bridge run --hz 10\n\n# Test telemetry reading\nuv run ac-bridge test-telemetry --hz 10 --duration 30\n\n# Test control output\nuv run ac-bridge test-control\n\n# Full integration test\nuv run ac-bridge smoke-test --duration 10\n\n# Reset session\nuv run ac-bridge reset\n\n# Stream to cloud\nuv run ac-bridge cloud --uri ws://your-server:8765\n</code></pre>"},{"location":"api/overview/#thread-safety","title":"Thread Safety","text":"<p><code>ACBridgeLocal</code> is thread-safe: - Background thread polls telemetry - Main thread calls <code>latest_obs()</code> (reads from cache with lock) - Control calls are synchronous (vJoy is not thread-safe)</p> <p>Safe: Multiple <code>latest_obs()</code> calls from different threads Unsafe: Multiple <code>apply_action()</code> calls (use single control thread)</p>"},{"location":"api/overview/#timing-guarantees","title":"Timing Guarantees","text":"<ul> <li>Ticker: Maintains target frequency with drift correction</li> <li>dt_actual: Actual time since last frame (use for physics-based rewards)</li> <li>seq: Monotonic sequence number (detect dropped frames)</li> </ul> <p>If <code>seq</code> jumps (e.g., 42\u219244), one frame was dropped. This is rare but possible under heavy load.</p>"},{"location":"api/overview/#customization","title":"Customization","text":""},{"location":"api/overview/#custom-observation-space","title":"Custom Observation Space","text":"<p>Edit <code>ACBridgeLocal._read_and_process_telemetry()</code> to change observation vector:</p> <pre><code>obs = np.array([\n    # Your custom features\n    info['speed_kmh'] / 300.0,\n    info['distance_traveled'] / 10000.0,\n    # ... add more fields\n], dtype=np.float32)\n</code></pre>"},{"location":"api/overview/#custom-reset-behavior","title":"Custom Reset Behavior","text":"<p>Modify <code>ACBridgeLocal.reset()</code> to change button sequence or wait times.</p>"},{"location":"api/overview/#attribution","title":"Attribution","text":"<p>Based on: - DIY-DirectDrive - Shared memory structures - assetto_corsa_gym - vJoy control patterns</p>"},{"location":"api/overview/#version","title":"Version","text":"<p>ac-bridge v0.2.0</p>"},{"location":"api/stepper/","title":"RealTimeStepper API","text":"<p><code>RealTimeStepper</code> enforces consistent timing for RL training by aligning actions with observations.</p>"},{"location":"api/stepper/#the-problem","title":"The Problem","text":"<p>Without a stepper:</p> <pre><code>bridge.apply_action(action)  # Applied immediately\nobs = bridge.latest_obs()     # Read immediately (0ms later!)\n# Problem: Observation doesn't reflect action's effect yet\n</code></pre> <p>With a stepper:</p> <pre><code>obs, info = stepper.step(action)\n# 1. Applies action\n# 2. Waits until next 10 Hz tick\n# 3. Reads observation *after* action took effect\n# Result: Consistent action\u2192observation causality\n</code></pre>"},{"location":"api/stepper/#usage","title":"Usage","text":"<pre><code>from ac_bridge import ACBridgeLocal, RealTimeStepper\n\nbridge = ACBridgeLocal(telemetry_hz=60, control_hz=10)\nstepper = RealTimeStepper(bridge, control_hz=10)\n\nbridge.connect()\n\n# Reset (triggers session restart)\nobs, info = stepper.reset()\n\n# Training loop\nfor episode in range(100):\n    action = policy(obs)\n    obs, info = stepper.step(action)\n    reward = compute_reward(obs, info)\n\n    if done:\n        obs, info = stepper.reset()\n\nbridge.close()\n</code></pre>"},{"location":"api/stepper/#methods","title":"Methods","text":""},{"location":"api/stepper/#__init__bridge-control_hz10","title":"<code>__init__(bridge, control_hz=10)</code>","text":"<p>Args: - <code>bridge</code>: ACBridgeLocal instance - <code>control_hz</code>: Control rate in Hz (default: 10)</p>"},{"location":"api/stepper/#stepaction-tupleobs-info","title":"<code>step(action) -&gt; tuple[obs, info]</code>","text":"<p>Apply action and return next observation.</p> <p>Args: - <code>action</code>: np.ndarray of shape (3,) with [steer, throttle, brake]   - Or dict: <code>{'steer': float, 'throttle': float, 'brake': float}</code></p> <p>Returns: - <code>obs</code>: 15-dim observation vector - <code>info</code>: Telemetry dict with timing metadata</p> <p>Timing guarantee: - Action is applied for exactly <code>dt = 1/control_hz</code> seconds - Drift correction maintains &lt;1ms accuracy</p>"},{"location":"api/stepper/#reset-tupleobs-info","title":"<code>reset() -&gt; tuple[obs, info]</code>","text":"<p>Restart session and return initial observation.</p> <p>Calls <code>bridge.reset()</code> which: 1. Presses button 7 (restart race) 2. Waits 2s, presses button 9 (start race) 3. Resets controls and shifts to 1st gear</p>"},{"location":"api/stepper/#get_stats-dict","title":"<code>get_stats() -&gt; dict</code>","text":"<p>Returns timing statistics:</p> <pre><code>{\n    'total_steps': 10000,\n    'avg_step_duration': 0.1001,  # Close to target 0.1s\n    'avg_drift': 0.0003,           # &lt;1ms drift\n    'max_drift': 0.0012,\n    'drift_corrections': 42        # Times drift was corrected\n}\n</code></pre>"},{"location":"api/stepper/#timing-details","title":"Timing Details","text":"<p>The stepper uses a drift-correcting ticker:</p> <pre><code>target_dt = 1 / control_hz  # e.g., 0.1s for 10 Hz\n\nfor tick in ticker:\n    # Apply action\n    bridge.apply_action(action)\n\n    # Wait until next tick boundary\n    ticker.sleep_until_next()  # Corrects for drift\n\n    # Read observation\n    obs, info = bridge.latest_obs()\n</code></pre> <p>Drift correction: - Measures actual elapsed time each step - Adjusts next sleep duration to compensate - Maintains long-term frequency accuracy</p>"},{"location":"api/stepper/#action-formats","title":"Action Formats","text":"<p>The stepper accepts multiple action formats:</p> <pre><code># NumPy array (recommended)\naction = np.array([steer, throttle, brake])\nobs, info = stepper.step(action)\n\n# Dict\naction = {'steer': 0.5, 'throttle': 0.8, 'brake': 0.0}\nobs, info = stepper.step(action)\n\n# Tuple/list\naction = (0.5, 0.8, 0.0)\nobs, info = stepper.step(action)\n</code></pre>"},{"location":"api/stepper/#integration-with-gym","title":"Integration with Gym","text":"<pre><code>class ACEnv(gym.Env):\n    def __init__(self):\n        self.bridge = ACBridgeLocal(control_hz=10)\n        self.stepper = RealTimeStepper(self.bridge, control_hz=10)\n        # ...\n\n    def step(self, action):\n        obs, info = self.stepper.step(action)\n        reward = self._compute_reward(obs, info)\n        done = self._check_done(info)\n        return obs, reward, done, False, info\n\n    def reset(self):\n        obs, info = self.stepper.reset()\n        return obs, info\n</code></pre>"},{"location":"api/stepper/#performance","title":"Performance","text":"<p>Typical step timing @ 10 Hz:</p> <ul> <li>Target: 100.0ms</li> <li>Actual: 100.0-100.3ms (includes drift correction)</li> <li>Overhead: ~0.1ms for timing logic</li> </ul> <p>Long-term accuracy: - 10,000 steps should take 1000.0s \u00b1 10ms</p>"},{"location":"api/stepper/#see-also","title":"See Also","text":"<ul> <li>ACBridgeLocal - Core bridge API</li> <li>Timing System - Clock and ticker details</li> </ul>"},{"location":"systems/control/","title":"Control System Documentation","text":""},{"location":"systems/control/#overview","title":"Overview","text":"<p>The control system enables sending commands to Assetto Corsa via vJoy (virtual joystick). This provides low-latency control for reinforcement learning training and automated driving.</p>"},{"location":"systems/control/#architecture","title":"Architecture","text":"<pre><code>graph LR\n    Python[Python Policy] --&gt;|pyvjoy API| vJoyDriver[vJoy Driver]\n    vJoyDriver --&gt;|DirectInput| AC[Assetto Corsa]\n\n    note1[Latency: 3-8ms total]\n</code></pre> <p>Components: - VJoyController: Python class for sending control commands - vJoy Driver: Kernel-mode virtual joystick driver (Windows) - DirectInput: Standard Windows game input API</p> <p>Latency: - Python \u2192 vJoy: 1-2ms - vJoy \u2192 AC: 2-5ms - Total: 3-8ms (comparable to physical wheel)</p>"},{"location":"systems/control/#installation","title":"Installation","text":""},{"location":"systems/control/#1-install-vjoy-driver","title":"1. Install vJoy Driver","text":"<p>Download and install vJoy from: https://sourceforge.net/projects/vjoystick/</p> <p>Run the installer with default settings.</p>"},{"location":"systems/control/#2-configure-vjoy-device","title":"2. Configure vJoy Device","text":"<p>Open \"Configure vJoy\" application:</p> <p>Device 1 Settings: - Enable: \u2713 - Axes:   - X Axis: \u2713 (Steering)   - Y Axis: \u2713 (Throttle)   - Z Axis: \u2713 (Brake)   - RZ Rotation: \u2713 (Clutch) - Buttons: 12 or more (recommended) - POV Hat Switch: 0 (disabled)</p> <p>Click \"Apply\" to save configuration.</p>"},{"location":"systems/control/#3-install-python-dependencies","title":"3. Install Python Dependencies","text":"<p>The <code>pyvjoy</code> library is included in project dependencies:</p> <pre><code>uv sync\n</code></pre>"},{"location":"systems/control/#4-configure-assetto-corsa","title":"4. Configure Assetto Corsa","text":"<p>In AC, go to Options \u2192 Controls:</p> <ol> <li>Select \"vJoy Device\" as controller</li> <li>Map axes:</li> <li>Steering: X Axis</li> <li>Throttle: Y Axis</li> <li>Brake: Z Axis</li> <li>Clutch: RZ Axis</li> <li>Set all axis ranges:</li> <li>Minimum: -100%</li> <li>Maximum: +100%</li> <li>Deadzone: 0%</li> <li>Gamma: 1.0</li> </ol>"},{"location":"systems/control/#5-button-mappings","title":"5. Button Mappings","text":"<p>Map vJoy buttons in AC for full functionality:</p> vJoy Button Recommended Mapping Required for AC Bridge Button 1 Next gear No (optional) Button 2 Previous gear No (optional) Button 3 Brake balance \u2192 front No (optional) Button 4 Brake balance \u2192 rear No (optional) Button 5 Traction control + No (optional) Button 6 Traction control - No (optional) Button 7 Restart race Yes \u26a0\ufe0f Button 8 Restart session No Button 9 Start race Yes \u26a0\ufe0f Button 10-12 (Unassigned) No <p>Required for Reset</p> <p>Buttons 7 and 9 are required for <code>ACBridgeLocal.reset()</code> to work properly:</p> <ul> <li>Button 7 triggers the race restart</li> <li>Button 9 starts the race after restart</li> </ul> <p>The reset sequence: Press button 7 \u2192 Wait 2s \u2192 Press button 9 \u2192 Reset controls \u2192 Shift to 1st gear</p> <p>Interactive Button Testing</p> <p>Use the interactive test tool to verify button mappings: <pre><code>uv run examples/test_control.py\n# Press 'b1' through 'b12' to test each button\n</code></pre></p>"},{"location":"systems/control/#usage","title":"Usage","text":""},{"location":"systems/control/#quick-test","title":"Quick Test","text":"<p>Verify vJoy installation:</p> <pre><code>uv run main.py test-control\n</code></pre> <p>Use keyboard controls (W/A/S/D) to test throttle, brake, and steering.</p>"},{"location":"systems/control/#python-api","title":"Python API","text":"<pre><code>from ac_bridge.control import VJoyController\n\n# Initialize controller\ncontroller = VJoyController(device_id=1)\n\n# Set individual controls\ncontroller.set_throttle(0.8)    # 80% throttle\ncontroller.set_brake(0.0)       # No brake\ncontroller.set_steering(-0.5)   # Half left\ncontroller.set_clutch(0.0)      # Clutch released\n\n# Batch update (most efficient)\ncontroller.set_controls(\n    throttle=0.8,\n    brake=0.0,\n    steering=-0.5,\n    clutch=0.0\n)\n\n# Gear shifting\ncontroller.set_gear(3)  # 2nd gear (0=R, 1=N, 2=1st, 3=2nd, ...)\n\n# Reset to neutral\ncontroller.reset()\n\n# Clean up\ncontroller.close()\n</code></pre>"},{"location":"systems/control/#value-ranges","title":"Value Ranges","text":"Control Range Notes Throttle 0.0 - 1.0 0=off, 1=full Brake 0.0 - 1.0 0=off, 1=full Clutch 0.0 - 1.0 0=released, 1=pressed Steering -1.0 - 1.0 -1=full left, 0=center, 1=full right Gear 0-7 0=R, 1=N, 2=1st, 3=2nd, etc."},{"location":"systems/control/#closed-loop-example","title":"Closed-Loop Example","text":"<pre><code>from ac_bridge.telemetry.ac_native_memory import ACSharedMemory\nfrom ac_bridge.control import VJoyController\nimport time\n\nasm = ACSharedMemory()\ncontroller = VJoyController()\n\nwhile True:\n    # Read telemetry\n    p = asm.physics\n    speed = p.speedKmh\n\n    # Simple speed control\n    target_speed = 100.0\n    error = target_speed - speed\n    throttle = max(0.0, min(1.0, error * 0.01))\n\n    # Apply control\n    controller.set_throttle(throttle)\n\n    time.sleep(0.02)  # 50 Hz\n</code></pre>"},{"location":"systems/control/#cloud-training-integration","title":"Cloud Training Integration","text":"<p>On Windows (home PC): <pre><code># Receive controls from cloud\nuv run main.py control-from-cloud --uri ws://your-ec2:8766\n</code></pre></p> <p>On Cloud (EC2): <pre><code>import asyncio\nimport json\nimport websockets\n\nasync def send_controls():\n    async with websockets.connect(\"ws://windows-pc:8766\") as ws:\n        # Send control command\n        controls = {\n            \"throttle\": 0.8,\n            \"brake\": 0.0,\n            \"steering\": -0.2,\n            \"clutch\": 0.0\n        }\n        await ws.send(json.dumps(controls))\n\nasyncio.run(send_controls())\n</code></pre></p>"},{"location":"systems/control/#performance-optimization","title":"Performance Optimization","text":""},{"location":"systems/control/#value-caching","title":"Value Caching","text":"<p>The <code>VJoyController</code> caches values and only sends updates when values change:</p> <pre><code># Only sends one vJoy command (value unchanged)\ncontroller.set_throttle(0.5)\ncontroller.set_throttle(0.5)  # Skipped (cached)\ncontroller.set_throttle(0.6)  # Sent (changed)\n</code></pre>"},{"location":"systems/control/#batch-updates","title":"Batch Updates","text":"<p>Use <code>set_controls()</code> for multiple axes to minimize API calls:</p> <pre><code># Efficient: Single update\ncontroller.set_controls(throttle=0.8, brake=0.0, steering=-0.3)\n\n# Less efficient: Multiple updates\ncontroller.set_throttle(0.8)\ncontroller.set_brake(0.0)\ncontroller.set_steering(-0.3)\n</code></pre>"},{"location":"systems/control/#update-rate","title":"Update Rate","text":"<p>Target 50-100 Hz for smooth control:</p> <pre><code>rate_hz = 60\nsleep_time = 1.0 / rate_hz\n\nwhile running:\n    controller.set_controls(...)\n    time.sleep(sleep_time)\n</code></pre> <p>Higher rates (&gt;100 Hz) provide diminishing returns due to AC's internal polling rate.</p>"},{"location":"systems/control/#troubleshooting","title":"Troubleshooting","text":""},{"location":"systems/control/#error-failed-to-initialize-vjoy-device","title":"Error: Failed to initialize vJoy device","text":"<p>Cause: vJoy driver not installed or device not configured</p> <p>Solution: 1. Install vJoy from https://sourceforge.net/projects/vjoystick/ 2. Open \"Configure vJoy\" and enable device 1 3. Verify 4 axes are enabled (X, Y, Z, RZ) 4. Click \"Apply\"</p>"},{"location":"systems/control/#controls-not-responding-in-ac","title":"Controls not responding in AC","text":"<p>Cause: AC not configured for vJoy</p> <p>Solution: 1. In AC: Options \u2192 Controls \u2192 Controller 2. Select \"vJoy Device\" 3. Map throttle, brake, steering, clutch 4. Remove deadzones (set to 0%) 5. Test controls in AC before using Python</p>"},{"location":"systems/control/#high-latency-jerky-control","title":"High latency / jerky control","text":"<p>Cause: Update rate too low or system overload</p> <p>Solution: 1. Increase control update rate (60-100 Hz) 2. Use <code>set_controls()</code> instead of individual axis updates 3. Reduce telemetry polling rate if CPU-bound 4. Close background applications</p>"},{"location":"systems/control/#vjoy-device-busy-in-use","title":"vJoy device busy / in use","text":"<p>Cause: Another application using vJoy device 1</p> <p>Solution: 1. Close other apps using vJoy 2. Or use different device ID: <code>VJoyController(device_id=2)</code> 3. Configure device 2 in \"Configure vJoy\" first</p>"},{"location":"systems/control/#steeringthrottle-stuck-at-max","title":"Steering/throttle stuck at max","text":"<p>Cause: Axis range misconfigured in AC</p> <p>Solution: 1. AC Options \u2192 Controls \u2192 Axes 2. Set minimum to -100%, maximum to +100% 3. Verify in calibration screen 4. Reset controller: <code>controller.reset()</code></p>"},{"location":"systems/control/#advanced-usage","title":"Advanced Usage","text":""},{"location":"systems/control/#custom-gear-mapping","title":"Custom Gear Mapping","text":"<p>Override gear shifting behavior:</p> <pre><code>class CustomGearController(VJoyController):\n    def set_gear(self, gear: int):\n        # Custom H-pattern mapping using buttons 1-7\n        for i in range(1, 8):\n            self.device.set_button(i, 1 if i == gear else 0)\n</code></pre>"},{"location":"systems/control/#multi-device-setup","title":"Multi-Device Setup","text":"<p>Control multiple vJoy devices:</p> <pre><code># Primary controls\ncontroller1 = VJoyController(device_id=1)\ncontroller1.set_controls(throttle=0.8, brake=0.0, steering=0.0)\n\n# Secondary inputs (e.g., handbrake, DRS)\ncontroller2 = VJoyController(device_id=2)\ncontroller2.device.set_button(1, 1)  # Handbrake\n</code></pre>"},{"location":"systems/control/#performance-monitoring","title":"Performance Monitoring","text":"<p>Track control performance:</p> <pre><code>stats = controller.get_stats()\nprint(f\"Updates: {stats['updates']}\")\nprint(f\"Rate: {stats['update_rate_hz']:.1f} Hz\")\nprint(f\"Duration: {stats['elapsed_seconds']:.1f}s\")\n</code></pre>"},{"location":"systems/control/#integration-with-rl-training","title":"Integration with RL Training","text":""},{"location":"systems/control/#observation-action-loop","title":"Observation-Action Loop","text":"<pre><code>import gymnasium as gym\nfrom ac_bridge.telemetry.ac_native_memory import ACSharedMemory\nfrom ac_bridge.control import VJoyController\n\nclass ACEnv(gym.Env):\n    def __init__(self):\n        self.telemetry = ACSharedMemory()\n        self.controller = VJoyController()\n\n    def reset(self):\n        self.controller.reset()\n        return self._get_obs()\n\n    def step(self, action):\n        # Apply action\n        self.controller.set_controls(\n            throttle=action[0],\n            brake=action[1],\n            steering=action[2]\n        )\n\n        # Wait for physics update\n        time.sleep(0.016)  # 60 Hz\n\n        # Get new observation\n        obs = self._get_obs()\n        reward = self._compute_reward()\n        done = self._check_termination()\n\n        return obs, reward, done, {}\n\n    def _get_obs(self):\n        p = self.telemetry.physics\n        return [\n            p.speedKmh / 300.0,\n            p.steerAngle / 900.0,\n            p.heading,\n            # ... more features\n        ]\n</code></pre>"},{"location":"systems/control/#cloud-training-setup","title":"Cloud Training Setup","text":"<p>See Cloud Setup for bidirectional telemetry + control over WebSocket.</p>"},{"location":"systems/control/#technical-details","title":"Technical Details","text":""},{"location":"systems/control/#vjoy-axis-mapping","title":"vJoy Axis Mapping","text":"vJoy Axis Usage ID AC Control Range X HID_USAGE_X Steering 0x1 - 0x8000 Y HID_USAGE_Y Throttle 0x1 - 0x8000 Z HID_USAGE_Z Brake 0x1 - 0x8000 RZ HID_USAGE_RZ Clutch 0x1 - 0x8000 <p>Internal conversion: - Float 0.0 \u2192 vJoy 0x1 (min) - Float 0.5 \u2192 vJoy 0x4000 (center) - Float 1.0 \u2192 vJoy 0x8000 (max)</p>"},{"location":"systems/control/#button-usage","title":"Button Usage","text":"<p>Buttons 1-8 can be mapped in AC for: - Gear up/down (sequential) - H-pattern gears (individual buttons) - DRS, KERS activation - Look left/right - Pit limiter</p>"},{"location":"systems/control/#latency-measurement","title":"Latency Measurement","text":"<p>Test round-trip latency:</p> <pre><code>import time\n\ncontroller = VJoyController()\nasm = ACSharedMemory()\n\n# Measure control \u2192 telemetry latency\nstart = time.perf_counter()\ncontroller.set_throttle(1.0)\n\nwhile asm.physics.gas &lt; 0.9:\n    time.sleep(0.001)\n\nlatency_ms = (time.perf_counter() - start) * 1000\nprint(f\"Control latency: {latency_ms:.1f}ms\")\n</code></pre> <p>Typical results: 5-15ms (includes AC's input polling + physics update).</p>"},{"location":"systems/control/#references","title":"References","text":"<ul> <li>vJoy Project: https://sourceforge.net/projects/vjoystick/</li> <li>pyvjoy Library: https://github.com/tidzo/pyvjoy</li> <li>Windows DirectInput API: https://docs.microsoft.com/en-us/windows/win32/directinput/</li> </ul>"},{"location":"systems/telemetry/","title":"Assetto Corsa Telemetry Parser","text":""},{"location":"systems/telemetry/#overview","title":"Overview","text":"<p>This project reads real-time telemetry data from Assetto Corsa using shared memory. The telemetry system provides comprehensive car state information including physics, graphics, and static data at configurable rates (1-60 Hz).</p>"},{"location":"systems/telemetry/#architecture","title":"Architecture","text":""},{"location":"systems/telemetry/#shared-memory-approach","title":"Shared Memory Approach","text":"<p>Assetto Corsa exposes three memory-mapped files for telemetry access:</p> <ol> <li>acpmf_physics - Updated every physics tick (typically 333 Hz)</li> <li>Car dynamics (speed, acceleration, forces)</li> <li>Wheel data (slip, load, temperature)</li> <li>Engine state (RPM, gear, fuel)</li> <li> <p>Control inputs (gas, brake, steering)</p> </li> <li> <p>acpmf_graphics - Updated every graphics frame (typically 60-144 Hz)</p> </li> <li>Lap timing and position</li> <li>Track limits and penalties</li> <li>Session information</li> <li> <p>UI state</p> </li> <li> <p>acpmf_static - Updated on session change</p> </li> <li>Car specifications</li> <li>Track information</li> <li>Session configuration</li> </ol>"},{"location":"systems/telemetry/#implementation","title":"Implementation","text":"<p>The native implementation uses Python's <code>mmap</code> and <code>ctypes</code> modules to map and read shared memory structures directly. This provides sub-millisecond latency access to telemetry data.</p>"},{"location":"systems/telemetry/#sources-and-attribution","title":"Sources and Attribution","text":"<p>This implementation is based on research and code from:</p> <ul> <li>DIY-DirectDrive Project by JanBalke420</li> <li>Repository: https://github.com/JanBalke420/DIY-DirectDrive</li> <li>Provided native AC shared memory structure definitions</li> <li> <p>Used for primary implementation in <code>ac_native_memory.py</code></p> </li> <li> <p>ac-remote-telemetry-client by rickwest</p> </li> <li>Repository: https://github.com/rickwest/ac-remote-telemetry-client</li> <li>Reference for AC UDP protocol investigation</li> <li> <p>Note: UDP approach was not used in final implementation due to reliability issues</p> </li> <li> <p>CrewChiefV4 by mrbelowski</p> </li> <li>Repository: https://github.com/mrbelowski/CrewChiefV4</li> <li>Analyzed for AC UDP protocol implementation</li> <li>Confirmed UDP telemetry requires handshake/subscribe protocol</li> <li> <p>Note: UDP approach abandoned in favor of shared memory</p> </li> <li> <p>pyaccsharedmemory library</p> </li> <li>Python package for ACC/AC shared memory access</li> <li>Note: Initially explored but not used in final implementation due to limited compatibility with original AC</li> </ul>"},{"location":"systems/telemetry/#why-shared-memory-instead-of-udp","title":"Why Shared Memory Instead of UDP","text":"<p>Initial development explored AC's UDP telemetry protocol based on references from ac-remote-telemetry-client and CrewChiefV4. The UDP approach was ultimately abandoned for the following reasons:</p> <ol> <li>Reliability Issues - UDP packets were inconsistently received even with proper handshake/subscribe implementation</li> <li>Protocol Complexity - Required maintaining bidirectional communication with handshake, subscription, and keepalive packets</li> <li>Port Conflicts - AC binds to port 9996 exclusively, preventing direct packet sniffing without relay software</li> <li>Session Dependency - Only works when actively driving, fails in menus or between sessions</li> <li>Latency - Even when working, UDP had higher and more variable latency than shared memory</li> </ol> <p>Shared memory provides: - Sub-millisecond read latency (&lt; 1ms vs 5-50ms for UDP) - 100% reliability (no dropped packets) - Simple implementation (single read operation, no protocol state machine) - Works regardless of AC's internal state - Direct access without intermediate relay software</p>"},{"location":"systems/telemetry/#key-telemetry-fields","title":"Key Telemetry Fields","text":""},{"location":"systems/telemetry/#track-limits-and-penalties","title":"Track Limits and Penalties","text":"<ul> <li><code>numberOfTyresOut</code> (int): Count of wheels off track (0-4)</li> <li>0: All wheels on track</li> <li>1-2: Minor cut (typically still valid)</li> <li> <p>3-4: Major cut (lap invalidated)</p> </li> <li> <p><code>is_lap_valid</code> (bool): Derived field tracking if current lap has been invalidated</p> </li> <li>Resets on lap completion</li> <li>Set to false when 3+ tyres go off track</li> </ul>"},{"location":"systems/telemetry/#wheel-dynamics","title":"Wheel Dynamics","text":"<ul> <li><code>wheelSlip</code> (float[4]): Slip ratio per wheel [FL, FR, RL, RR]</li> <li>0.0: Perfect grip (wheel speed matches ground speed)</li> <li>0.1-0.2: Optimal slip for maximum grip</li> <li>0.5+: Significant loss of traction</li> <li> <p>1.0: Complete lock (braking) or spin (acceleration)</p> </li> <li> <p><code>wheel_lock_detected</code> (bool): Derived field combining brake pressure and wheel slip</p> </li> <li>True when brake &gt; 0.5 AND avg wheel slip &gt; 0.5</li> <li>Indicates wheels have stopped rotating but car is still moving</li> </ul>"},{"location":"systems/telemetry/#damage-detection","title":"Damage Detection","text":"<ul> <li><code>carDamage</code> (float[5]): Body damage by section [front, rear, left, right, center]</li> <li>0.0: Pristine condition</li> <li>0.05-0.50: Minor to moderate damage</li> <li>0.50-1.0: Severe to destroyed</li> <li> <p>Derived fields: <code>bodywork_damaged</code> (&gt;5%), <code>bodywork_critical</code> (&gt;50%)</p> </li> <li> <p><code>tyreWear</code> (float[4]): Tire degradation per wheel [FL, FR, RL, RR]</p> </li> <li>0.0: New tire</li> <li>0.8: Significantly worn (grip reduction)</li> <li>0.95+: Critical wear (imminent failure)</li> <li>Derived fields: <code>tyre_damaged</code> (&gt;80%), <code>tyre_critical</code> (&gt;95%)</li> </ul>"},{"location":"systems/telemetry/#lap-timing","title":"Lap Timing","text":"<ul> <li><code>completedLaps</code> (int): Number of completed laps</li> <li><code>iCurrentTime</code> (int): Current lap time in milliseconds (also <code>current_time</code>)</li> <li><code>iLastTime</code> (int): Previous lap time in milliseconds (also <code>last_time</code>)</li> <li><code>iBestTime</code> (int): Best lap time in session in milliseconds (also <code>best_time</code>)</li> <li><code>distance_traveled</code> (float): Total distance traveled in meters</li> <li><code>normalized_position</code> (float): Position on track (0.0-1.0, where 1.0 is one lap)</li> <li><code>current_sector_index</code> (int): Current track sector (0, 1, or 2)</li> </ul>"},{"location":"systems/telemetry/#position-and-orientation","title":"Position and Orientation","text":"<ul> <li><code>velocity_x/y/z</code> (float): World-space velocity in m/s</li> <li><code>local_velocity_x/y/z</code> (float): Car-relative velocity [forward, up, right] in m/s</li> <li><code>world_position_x/y/z</code> (float): Car position in world coordinates</li> <li><code>yaw</code> (float): Car heading angle in radians (also available as <code>heading</code>)</li> <li><code>pitch</code> (float): Car pitch angle in radians</li> <li><code>roll</code> (float): Car roll angle in radians</li> <li><code>angular_velocity_x/y/z</code> (float): Rotation rates in rad/s [pitch rate, yaw rate, roll rate]</li> <li><code>acc_g_x/y/z</code> (float): G-forces in each axis</li> </ul>"},{"location":"systems/telemetry/#wheel-data","title":"Wheel Data","text":"<ul> <li><code>wheel_slip</code> (float[4]): Slip ratio per wheel [FL, FR, RL, RR]</li> <li><code>wheel_angular_speed</code> (float[4]): Wheel rotation speed in rad/s</li> <li><code>wheel_load</code> (float[4]): Load on each wheel in Newtons</li> <li><code>wheel_pressure</code> (float[4]): Tire pressure per wheel</li> <li><code>suspension_travel</code> (float[4]): Suspension compression per wheel</li> </ul>"},{"location":"systems/telemetry/#control-inputs","title":"Control Inputs","text":"<ul> <li><code>gas</code> (float): Throttle position 0.0-1.0</li> <li><code>brake</code> (float): Brake pressure 0.0-1.0</li> <li><code>clutch</code> (float): Clutch engagement 0.0-1.0</li> <li><code>steer_angle</code> (float): Steering wheel angle in degrees</li> </ul>"},{"location":"systems/telemetry/#temperature-and-environment","title":"Temperature and Environment","text":"<ul> <li><code>brake_temp</code> (float[4]): Brake temperature per wheel in Celsius</li> <li><code>tyre_core_temp</code> (float[4]): Tire core temperature per wheel in Celsius</li> <li><code>air_temp</code> (float): Ambient air temperature in Celsius</li> <li><code>road_temp</code> (float): Track surface temperature in Celsius</li> </ul>"},{"location":"systems/telemetry/#driver-assists","title":"Driver Assists","text":"<ul> <li><code>tc</code> (float): Traction control activation level 0.0-1.0</li> <li><code>abs_setting</code> (float): ABS configuration value (not activation level)</li> </ul>"},{"location":"systems/telemetry/#usage","title":"Usage","text":""},{"location":"systems/telemetry/#basic-telemetry-reading","title":"Basic Telemetry Reading","text":"<pre><code>uv run main.py read --rate 10\n</code></pre> <p>This outputs formatted telemetry at 10 Hz to the console.</p>"},{"location":"systems/telemetry/#json-export-for-rl-training","title":"JSON Export for RL Training","text":"<pre><code>uv run main.py read --rate 10 --json-output telemetry.jsonl\n</code></pre> <p>This writes JSONL (JSON Lines) format data suitable for ingestion by reinforcement learning pipelines.</p>"},{"location":"systems/telemetry/#performance-characteristics","title":"Performance Characteristics","text":""},{"location":"systems/telemetry/#latency","title":"Latency","text":"<ul> <li>Shared memory read: &lt; 1ms</li> <li>Memory map overhead: ~50 microseconds</li> <li>Python struct unpacking: ~100 microseconds</li> <li>Total latency: &lt; 2ms for complete telemetry read</li> </ul>"},{"location":"systems/telemetry/#update-rates","title":"Update Rates","text":"<ul> <li>Physics data: 333 Hz (AC internal physics rate)</li> <li>Graphics data: 60-144 Hz (varies with framerate)</li> <li>Recommended polling: 10-60 Hz for RL applications</li> <li>Maximum practical: 100 Hz (diminishing returns beyond this)</li> </ul>"},{"location":"systems/telemetry/#memory-overhead","title":"Memory Overhead","text":"<ul> <li>Physics structure: 1,320 bytes</li> <li>Graphics structure: 1,580 bytes</li> <li>Static structure: ~5,000 bytes</li> <li>Total mapped: ~8 KB (minimal footprint)</li> </ul>"},{"location":"systems/telemetry/#data-quality-notes","title":"Data Quality Notes","text":""},{"location":"systems/telemetry/#original-ac-implementation","title":"Original AC Implementation","text":"<p>The native implementation targets original Assetto Corsa (not Competizione). Some fields have specific semantics in AC:</p> <ul> <li><code>abs</code> field represents ABS configuration setting, not real-time activation level</li> <li><code>isValidLap</code> not directly available (derived from <code>numberOfTyresOut</code>)</li> </ul>"},{"location":"systems/telemetry/#field-reliability","title":"Field Reliability","text":"<p>Highly reliable fields: - Speed, RPM, gear, control inputs - Wheel slip, tire wear, damage - Lap times and lap count - numberOfTyresOut (most reliable track limit indicator)</p> <p>Less reliable fields: - Surface grip (track-dependent calibration) - Some penalty flags (inconsistent behavior) - ABS/TC activation (use derived metrics instead)</p>"},{"location":"systems/telemetry/#websocket-streaming","title":"WebSocket Streaming","text":"<p>The telemetry system includes a WebSocket server for real-time data streaming. This enables integration with external processes, cloud training, and multi-language clients.</p>"},{"location":"systems/telemetry/#architecture_1","title":"Architecture","text":"<pre><code>AC (Shared Memory) \u2192 Python Reader \u2192 WebSocket Server \u2192 Clients (Gym, Cloud, etc.)\n                        (10-60 Hz)      (Broadcast)       (Multiple)\n</code></pre>"},{"location":"systems/telemetry/#server-implementation","title":"Server Implementation","text":"<p>The server runs two concurrent tasks: 1. Telemetry Loop - Reads from shared memory at configured rate 2. WebSocket Handler - Manages client connections and broadcasts</p> <p>Key characteristics: - Non-blocking async I/O using <code>asyncio</code> and <code>websockets</code> - Broadcast pattern (one-to-many) - Automatic client cleanup on disconnect - JSON serialization for language-agnostic integration</p>"},{"location":"systems/telemetry/#client-connection","title":"Client Connection","text":"<p>Clients connect using standard WebSocket protocol:</p> <pre><code>import asyncio\nimport json\nimport websockets\n\nasync def receive():\n    async with websockets.connect(\"ws://localhost:8765\") as ws:\n        async for message in ws:\n            data = json.loads(message)\n            # Use telemetry data\n</code></pre>"},{"location":"systems/telemetry/#message-format","title":"Message Format","text":"<p>Each message is a complete telemetry snapshot in JSON: - All fields from shared memory - Derived metrics (wheel_lock_detected, is_lap_valid, etc.) - Timestamp for synchronization</p> <p>Message rate matches server broadcast rate (1-60 Hz configurable).</p>"},{"location":"systems/telemetry/#performance","title":"Performance","text":"<ul> <li>Server overhead: &lt; 1ms per broadcast</li> <li>JSON serialization: ~200 microseconds</li> <li>Network latency (localhost): &lt; 1ms</li> <li>Total latency: ~2-3ms from AC to client</li> </ul> <p>For remote connections, add network RTT to latency.</p>"},{"location":"systems/telemetry/#compatibility-with-other-projects","title":"Compatibility with Other Projects","text":""},{"location":"systems/telemetry/#assetto_corsa_gym-dataset","title":"assetto_corsa_gym Dataset","text":"<p>The telemetry output includes fields compatible with the assetto_corsa_gym project:</p> <ul> <li><code>angular_velocity_x/y/z</code> - Angular rotation rates</li> <li><code>world_position_x/y/z</code> - World coordinates</li> <li><code>velocity_x/y/z</code> - World-space velocity components</li> <li><code>distance_traveled</code> - Similar to LapDist</li> <li><code>yaw</code>, <code>roll</code>, <code>pitch</code> - Orientation</li> <li><code>packet_id</code> - Packet sequencing</li> <li><code>number_of_tyres_out</code> - Track limit detection (similar to out_of_track)</li> <li><code>steer_angle</code>, <code>gas</code>, <code>brake</code> - Control inputs</li> <li><code>rpm</code>, <code>gear</code> - Engine state</li> <li><code>completed_laps</code> - Lap count</li> </ul> <p>Additional physics data available: - <code>wheel_angular_speed</code> - Individual wheel rotation speeds - <code>wheel_load</code> - Load per wheel - <code>wheel_pressure</code> - Tire pressure - <code>suspension_travel</code> - Suspension compression</p>"},{"location":"systems/telemetry/#integration-with-gymnasium","title":"Integration with Gymnasium","text":"<p>The telemetry data is structured for easy integration with Gymnasium environments:</p>"},{"location":"systems/telemetry/#state-observation-space","title":"State Observation Space","text":"<p>Recommended fields for observation vector: - Speed, RPM, gear - Control inputs (gas, brake, steer) - Wheel slip (individual or average) - Position on track (normalizedCarPosition) - G-forces (lateral/longitudinal acceleration) - Tire wear and temperatures</p>"},{"location":"systems/telemetry/#reward-shaping","title":"Reward Shaping","text":"<p>Useful fields for reward calculation: - <code>iCurrentTime</code> - Lap time improvement - <code>numberOfTyresOut</code> - Track limits penalty - <code>wheel_lock_detected</code> - Driving quality penalty - <code>tyreWear</code> - Tire management reward - <code>normalizedCarPosition</code> - Progress tracking</p>"},{"location":"systems/telemetry/#termination-conditions","title":"Termination Conditions","text":"<p>Episode termination triggers: - <code>bodywork_critical</code> - Severe crash - <code>tyre_critical</code> - Catastrophic tire failure - <code>numberOfTyresOut &gt;= 4</code> - Complete off-track - Timeout (lap time exceeds threshold)</p>"},{"location":"systems/telemetry/#technical-considerations","title":"Technical Considerations","text":""},{"location":"systems/telemetry/#windows-memory-mapping","title":"Windows Memory Mapping","text":"<p>The shared memory implementation uses Windows-specific APIs via ctypes. Memory-mapped files are accessed via:</p> <pre><code>mmap.mmap(-1, size, tagname)\n</code></pre> <p>The <code>tagname</code> corresponds to AC's published memory handles: - \"acpmf_physics\" - \"acpmf_graphics\" - \"acpmf_static\"</p>"},{"location":"systems/telemetry/#structure-packing","title":"Structure Packing","text":"<p>All structures use 4-byte alignment (<code>_pack_ = 4</code>) to match AC's memory layout. Incorrect packing will cause field misalignment and incorrect data reads.</p>"},{"location":"systems/telemetry/#threading-and-synchronization","title":"Threading and Synchronization","text":"<p>AC updates shared memory asynchronously. No explicit locking is required as reads are atomic for aligned data types. However, consistency within a single read is not guaranteed across different memory sections (physics vs graphics).</p> <p>For RL applications, read all required data in a single pass and timestamp it, rather than making multiple reads across decision boundaries.</p>"},{"location":"systems/timing-protocol/","title":"Timing &amp; Protocol","text":""},{"location":"systems/timing-protocol/#timing-system","title":"Timing System","text":"<p>AC Bridge includes high-precision timing for stable RL training.</p>"},{"location":"systems/timing-protocol/#monotonicclock","title":"MonotonicClock","text":"<p>Wraps <code>time.perf_counter()</code> for consistent, monotonic time:</p> <pre><code>from ac_bridge import MonotonicClock\n\nclock = MonotonicClock()\nstart = clock.now()  # High-resolution timestamp\n# ... do work ...\nelapsed = clock.now() - start\n</code></pre>"},{"location":"systems/timing-protocol/#ticker","title":"Ticker","text":"<p>Drift-correcting frequency generator for consistent loop timing:</p> <pre><code>from ac_bridge import Ticker\n\nticker = Ticker(hz=10)  # 10 Hz = 100ms per tick\n\nfor tick_info in ticker:\n    # Do work\n    print(f\"Tick {tick_info['seq']}: dt={tick_info['dt_actual']:.3f}s\")\n\n    # Ticker automatically corrects drift\n    # Long-term frequency is maintained at exactly 10 Hz\n</code></pre> <p>Drift Correction:</p> <pre><code># Without correction (naive sleep):\nfor i in range(1000):\n    do_work()\n    time.sleep(0.1)  # Actual: 0.1002s per iteration\n# Total: 1000 * 0.1002 = 100.2s (200ms drift!)\n\n# With Ticker (drift correction):\nticker = Ticker(hz=10)\nfor tick_info in ticker:\n    do_work()\n# Total: exactly 100.0s (\u00b11ms)\n</code></pre>"},{"location":"systems/timing-protocol/#integration","title":"Integration","text":"<p>The stepper and bridge use <code>Ticker</code> internally:</p> <pre><code># In RealTimeStepper.step():\nticker = Ticker(hz=control_hz)\nfor tick in ticker:\n    bridge.apply_action(action)\n    obs, info = bridge.latest_obs()\n    # Add timing metadata\n    info['seq'] = tick['seq']\n    info['t_wall'] = tick['t_wall']\n    info['dt'] = tick['dt']\n    info['dt_actual'] = tick['dt_actual']\n</code></pre>"},{"location":"systems/timing-protocol/#protocol","title":"Protocol","text":""},{"location":"systems/timing-protocol/#message-types","title":"Message Types","text":"<p>AC Bridge defines typed message schemas for communication:</p> <pre><code>from ac_bridge import TelemetryFrame, ControlCommand, Transition\n\n# Telemetry\nframe = TelemetryFrame(\n    seq=123,\n    t_wall=45.67,\n    speed_kmh=145.3,\n    rpm=5420,\n    # ... 40+ fields\n)\n\n# Control\ncmd = ControlCommand(\n    seq=123,\n    steer=0.5,\n    throttle=0.8,\n    brake=0.0\n)\n\n# Transition (for actor-learner)\ntrans = Transition(\n    obs=np.array([...]),\n    action=np.array([...]),\n    reward=1.0,\n    done=False,\n    info={'speed': 145.3}\n)\n</code></pre>"},{"location":"systems/timing-protocol/#codec","title":"Codec","text":"<p>Supports JSON and MessagePack:</p> <pre><code>from ac_bridge import Codec\n\ncodec = Codec(format='json')  # or 'msgpack'\n\n# Encode\ndata = codec.encode(frame)\n\n# Decode\nframe = codec.decode(data, TelemetryFrame)\n</code></pre> <p>MessagePack is 3-5x faster and more compact than JSON for high-frequency streaming.</p>"},{"location":"systems/timing-protocol/#timing-metadata","title":"Timing Metadata","text":"<p>Every telemetry frame includes:</p> <ul> <li>seq (int): Sequence number (monotonically increasing)</li> <li>t_wall (float): Wall clock time in seconds (perf_counter)</li> <li>dt (float): Target delta time (e.g., 0.1s for 10 Hz)</li> <li>dt_actual (float): Actual time since last frame</li> </ul> <p>This enables: - Detecting dropped frames (<code>seq</code> gaps) - Measuring loop latency (<code>dt_actual</code> vs <code>dt</code>) - Synchronizing distributed components (<code>t_wall</code>)</p>"},{"location":"systems/timing-protocol/#see-also","title":"See Also","text":"<ul> <li>Cloud Setup - WebSocket streaming</li> <li>Advanced Protocol - Message batching</li> </ul>"}]}